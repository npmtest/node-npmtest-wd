{"/home/travis/build/npmtest/node-npmtest-wd/test.js":"/* istanbul instrument in package npmtest_wd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wd/lib.npmtest_wd.js":"/* istanbul instrument in package npmtest_wd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_wd = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_wd = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-wd/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-wd && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_wd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_wd\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_wd.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_wd.rollup.js'] =\n            local.assetsDict['/assets.npmtest_wd.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_wd.__dirname + '/lib.npmtest_wd.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/main.js":"var __slice = Array.prototype.slice,\n    url = require('url'),\n    SPECIAL_KEYS = require('./special-keys'),\n    Webdriver = require('./webdriver'),\n    Element = require('./element'),\n    utils = require('./utils'),\n    deprecator = utils.deprecator,\n    config = require('./config'),\n    _ = require(\"./lodash\"),\n    Q = require('q'),\n    actions = require('./actions');\n\nfunction buildConfigUrl(remoteWdConfig)\n{\n  var configUrl = _(remoteWdConfig).clone();\n\n  // for backward compatibility\n  if( configUrl.host && (configUrl.host.indexOf(':') < 0) && configUrl.port )\n  {\n    configUrl.hostname = configUrl.host;\n    delete configUrl.host;\n  }\n\n  // for backward compatibility\n  if(configUrl.username){\n    configUrl.user = configUrl.username;\n    delete configUrl.username;\n  }\n\n  // for backward compatibility\n  if(configUrl.accessKey){\n    configUrl.pwd = configUrl.accessKey;\n    delete configUrl.accessKey;\n  }\n\n  // for backward compatibility\n  if(configUrl.https){\n    configUrl.protocol = 'https:';\n    delete configUrl.https;\n  }\n\n  // for backward compatibility\n  if(configUrl.path){\n    configUrl.pathname = configUrl.path;\n    delete configUrl.path;\n  }\n\n  // setting auth from user/password\n  if(configUrl.user && configUrl.pwd){\n    configUrl.auth = configUrl.user + ':' + configUrl.pwd;\n    delete configUrl.user;\n    delete configUrl.pwd;\n  }\n\n  _.defaults(configUrl, {\n    protocol: 'http:',\n    hostname: '127.0.0.1',\n    port: '4444',\n    pathname: '/wd/hub'\n  });\n\n  // strip any trailing slashes from pathname\n  var parsed = url.parse(url.format(configUrl), true);\n  if (parsed.pathname[parsed.pathname.length - 1] === '/') {\n    parsed.pathname = parsed.pathname.slice(0, parsed.pathname.length - 1);\n  }\n  return parsed;\n}\n\n// parses server parameters\nvar parseRemoteWdConfig = function(args) {\n  var config;\n  if ((typeof args[0]) === 'object') {\n    if(args[0].href && args[0].format){\n      // was constructed with url.parse, so we don't modify it\n      config = args[0];\n    } else {\n      config = buildConfigUrl( args[0] );\n    }\n  } else if ((typeof args[0]) === 'string' && (args[0].match(/^https?:\\/\\//)))  {\n    config = url.parse(args[0]);\n  } else {\n    config = buildConfigUrl( {\n      hostname: args[0],\n      port: args[1],\n      user: args[2],\n      pwd: args[3]\n    } );\n  }\n\n  // saucelabs automatic config\n  if( /saucelabs\\.com/.exec(config.hostname) )\n  {\n    if(!config.auth && process.env.SAUCE_USERNAME && process.env.SAUCE_ACCESS_KEY){\n      config.auth = process.env.SAUCE_USERNAME + ':' + process.env.SAUCE_ACCESS_KEY;\n    }\n  }\n\n  return config;\n};\n\nvar PromiseWebdriver, PromiseElement, PromiseChainWebdriver, PromiseChainElement;\n\n// Creates the Webdriver object\n// server parameters can be passed in 4 ways\n//   - as a url string\n//   - as a url object, constructed via url.parse\n//   - as a list of arguments host,port, user, pwd\n//   - as an option object containing the fields above\n// A `driverType` string may be passed at the end of the argument list.\n// If it is a valid type it will be detected even if the other arguments\n// are ommited. Valide types are: `remote`, `promise` and `promiseChain`.\nfunction remote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var driverProtos = {\n    'async': Webdriver,\n    'promise': PromiseWebdriver,\n    'promiseChain': PromiseChainWebdriver\n  };\n  var driverTypes = _(driverProtos).keys().value();\n  var driverType = driverTypes.indexOf(_(args).last())>0 ? args.pop() : 'async';\n\n  var rwc = parseRemoteWdConfig(args);\n  return new (driverProtos[driverType])(rwc);\n}\n\nfunction wrap() {\n  var promiseProtos = require('./promise-webdriver')(Webdriver, Element, false);\n  PromiseWebdriver = promiseProtos.PromiseWebdriver;\n  PromiseElement = promiseProtos.PromiseElement;\n  var promiseChainProtos = require('./promise-webdriver')(Webdriver, Element, true);\n  PromiseChainWebdriver = promiseChainProtos.PromiseWebdriver;\n  PromiseChainElement = promiseChainProtos.PromiseElement;\n}\n\n// todo: allow adding element methods\n\nfunction addPromiseChainMethod(name, method) {\n  var wrappedMethod = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    var promise = new Q(method.apply(this, args));\n    this._enrich(promise);\n    return promise;\n  };\n  PromiseChainWebdriver.prototype[name] = wrappedMethod;\n}\n\nfunction addElementPromiseChainMethod(name, method) {\n  var wrappedMethod = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    var promise = new Q(method.apply(this, args));\n    this._enrich(promise);\n    return promise;\n  };\n  PromiseChainElement.prototype[name] = wrappedMethod;\n}\n\nfunction addPromiseMethod(name, method) {\n  var wrappedMethod = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return new Q(method.apply(this, args));\n  };\n  PromiseWebdriver.prototype[name] = wrappedMethod;\n  addPromiseChainMethod(name, method);\n}\n\nfunction addElementPromiseMethod(name, method) {\n  var wrappedMethod = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return new Q(method.apply(this, args));\n  };\n  PromiseElement.prototype[name] = wrappedMethod;\n  addElementPromiseChainMethod(name, method);\n}\n\nfunction addAsyncMethod(name, method) {\n  Webdriver.prototype[name] = method;\n  PromiseWebdriver.prototype[name] = PromiseWebdriver._wrapAsync(method);\n  PromiseChainWebdriver.prototype[name] = PromiseChainWebdriver._wrapAsync(method);\n}\n\nfunction addElementAsyncMethod(name, method) {\n  Element.prototype[name] = method;  \n  PromiseElement.prototype[name] = PromiseWebdriver._wrapAsync(method);\n  PromiseChainElement.prototype[name] = PromiseChainWebdriver._wrapAsync(method);\n}\n\nfunction removeMethod(name) {\n  delete Webdriver.prototype[name];\n  delete PromiseWebdriver.prototype[name];\n  delete PromiseChainWebdriver.prototype[name];\n}\n\n// creates a webdriver object using the Q promise wrap not chained\nfunction asyncRemote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var rwc = parseRemoteWdConfig(args);\n  return new Webdriver(rwc);\n}\n\n// creates a webdriver object using the Q promise wrap not chained\nfunction promiseRemote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var rwc = parseRemoteWdConfig(args);\n  return new PromiseWebdriver(rwc);\n}\n\n// creates a webdriver object using the Q promise wrap chained\nfunction promiseChainRemote() {\n  var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  var rwc = parseRemoteWdConfig(args);\n  return new PromiseChainWebdriver(rwc);\n}\n\n// initial wrapping\nwrap();\n\nmodule.exports = {\n  // Retrieves browser\n  remote: remote,\n  asyncRemote: asyncRemote,\n\n  // Retrieves wrap browser\n  promiseRemote: promiseRemote,\n  promiseChainRemote: promiseChainRemote,\n\n  // Webdriver and Wrapper base classes\n  Webdriver: Webdriver,\n  webdriver: Webdriver, // for backward compatibility\n  Element: Element,\n  PromiseChainWebdriver: PromiseChainWebdriver,\n  PromiseWebdriver: PromiseWebdriver,\n  TouchAction: actions.TouchAction,\n  MultiAction: actions.MultiAction,\n\n  // Actualizes promise wrappers\n  rewrap: function() {\n    deprecator.warn('rewrap',\n    'rewrap has been deprecated, use addAsyncMethod instead.');\n    wrap();\n  },\n\n  // config\n  /**\n   * wd.configureHttp(opts)\n   *\n   * opts example:\n   * {timeout:60000, retries: 3, 'retryDelay': 15, baseUrl='http://example.com/'}\n   * more info in README.\n   *\n   * @wd\n   */\n  configureHttp: config.configureHttp,\n  getHttpConfig: function() { return _(config.httpConfig).clone(); },\n\n  // deprecation\n  /**\n   * wd.showHideDeprecation(boolean)\n   *\n   * @wd\n   */\n  showHideDeprecation: deprecator.showHideDeprecation.bind(deprecator),\n\n  // add/remove methods\n  /**\n   * wd.addAsyncMethod(name, func)\n   *\n   * @wd\n   */\n  addAsyncMethod: addAsyncMethod,\n  /**\n   * wd.addElementAsyncMethod(name, func)\n   *\n   * @wd\n   */\n  addElementAsyncMethod: addElementAsyncMethod,\n  /**\n   * wd.addPromiseMethod(name, func)\n   *\n   * @wd\n   */\n  addPromiseMethod: addPromiseMethod,\n  /**\n   * wd.addElementPromiseMethod(name, func)\n   *\n   * @wd\n   */\n  addElementPromiseMethod: addElementPromiseMethod,\n  /**\n   * wd.addPromiseChainMethod(name, func)\n   *\n   * @wd\n   */\n  addPromiseChainMethod: addPromiseChainMethod,\n  /**\n   * wd.addElementPromiseChainMethod(name, func)\n   *\n   * @wd\n   */\n  addElementPromiseChainMethod: addElementPromiseChainMethod,\n  /**\n   * wd.removeMethod(name, func)\n   *\n   * @wd\n   */\n  removeMethod: removeMethod,\n\n  // Useful stuff\n  Asserter: require('./asserters').Asserter,\n  asserters: require('./asserters'),\n  SPECIAL_KEYS: SPECIAL_KEYS,\n  Q: Q,\n  findCallback: utils.findCallback,\n  varargs: utils.varargs,\n  transferPromiseness: utils.transferPromiseness,\n\n  // This is for people who write wrapper\n  // todo: That should not be needed.\n  utils: utils,\n\n  setBaseClasses: function(_Webdriver, _Element) {\n    Webdriver = _Webdriver;\n    Element = _Element;\n    wrap();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/special-keys.js":"var SPECIAL_KEYS = {\n  'NULL': '\\uE000',\n  'Cancel': '\\uE001',\n  'Help': '\\uE002',\n  'Back space': '\\uE003',\n  'Tab': '\\uE004',\n  'Clear': '\\uE005',\n  'Return': '\\uE006',\n  'Enter': '\\uE007',\n  'Shift': '\\uE008',\n  'Control': '\\uE009',\n  'Alt': '\\uE00A',\n  'Pause': '\\uE00B',\n  'Escape': '\\uE00C',\n  'Space': '\\uE00D',\n  'Pageup': '\\uE00E',\n  'Pagedown': '\\uE00F',\n  'End': '\\uE010',\n  'Home': '\\uE011',\n  'Left arrow': '\\uE012',\n  'Up arrow': '\\uE013',\n  'Right arrow': '\\uE014',\n  'Down arrow': '\\uE015',\n  'Insert': '\\uE016',\n  'Delete': '\\uE017',\n  'Semicolon': '\\uE018',\n  'Equals': '\\uE019',\n  'Numpad 0': '\\uE01A',\n  'Numpad 1': '\\uE01B',\n  'Numpad 2': '\\uE01C',\n  'Numpad 3': '\\uE01D',\n  'Numpad 4': '\\uE01E',\n  'Numpad 5': '\\uE01F',\n  'Numpad 6': '\\uE020',\n  'Numpad 7': '\\uE021',\n  'Numpad 8': '\\uE022',\n  'Numpad 9': '\\uE023',\n  'Multiply': '\\uE024',\n  'Add': '\\uE025',\n  'Separator': '\\uE026',\n  'Subtract': '\\uE027',\n  'Decimal': '\\uE028',\n  'Divide': '\\uE029',\n  'F1': '\\uE031',\n  'F2': '\\uE032',\n  'F3': '\\uE033',\n  'F4': '\\uE034',\n  'F5': '\\uE035',\n  'F6': '\\uE036',\n  'F7': '\\uE037',\n  'F8': '\\uE038',\n  'F9': '\\uE039',\n  'F10': '\\uE03A',\n  'F11': '\\uE03B',\n  'F12': '\\uE03C',\n  'Command': '\\uE03D',\n  'Meta': '\\uE03D'\n};\n\nmodule.exports = SPECIAL_KEYS;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/webdriver.js":"var EventEmitter = require('events').EventEmitter,\n    _ = require(\"./lodash\"),\n    util = require( 'util' ),\n    url = require('url'),\n    __slice = Array.prototype.slice,\n    utils = require(\"./utils\"),\n    findCallback = utils.findCallback,\n    niceArgs = utils.niceArgs,\n    niceResp = utils.niceResp,\n    strip = utils.strip,\n    deprecator = utils.deprecator,\n    httpUtils = require('./http-utils'),\n    config = require('./config'),\n    Element = require('./element'),\n    commands = require('./commands');\n\n// Webdriver client main class\n// configUrl: url object constructed via url.parse\nvar Webdriver = module.exports = function(configUrl) {\n  EventEmitter.call( this );\n  this.sessionID = null;\n  this.configUrl = configUrl;\n  this.sauceTestPageRoot = \"https://saucelabs.com/jobs\";\n  this.sauceRestRoot = \"https://saucelabs.com/rest/v1\";\n  // config url without auth\n  this.noAuthConfigUrl = url.parse(url.format(this.configUrl));\n  delete this.noAuthConfigUrl.auth;\n\n  this.defaultCapabilities = {\n    browserName: 'firefox'\n     , version: ''\n    , javascriptEnabled: true\n    , platform: 'ANY'\n  };\n\n  this._httpConfig = _.clone(config.httpConfig);\n};\n\n//inherit from EventEmitter\nutil.inherits( Webdriver, EventEmitter );\n\n// creates a new element\nWebdriver.prototype.newElement = function(jsonWireElement) {\n  return new Element(jsonWireElement, this);\n};\n\n/**\n * attach(sessionID, cb) -> cb(err)\n * Connect to an already-active session.\n */\nWebdriver.prototype.attach = function(sessionID) {\n  var cb = findCallback(arguments);\n  this.sessionID = sessionID;\n  if(cb) { cb(null); }\n};\n\n/**\n * detach(cb) -> cb(err)\n * Detach from the current session.\n */\nWebdriver.prototype.detach = function() {\n  var cb = findCallback(arguments);\n  this.sessionID = null;\n  if(cb) { cb(null); }\n};\n\ncommands.chain = function(obj){\n  deprecator.warn('chain', 'chain api has been deprecated, use promise chain instead.');\n  require(\"./deprecated-chain\").patch(this);\n  return this.chain(obj);\n};\n\nWebdriver.prototype._init = function() {\n  delete this.sessionID;\n  var _this = this;\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      desired = fargs.all[0] || {};\n\n  var _desired = _.clone(desired);\n\n  if(desired.deviceName || desired.device || desired.wdNoDefaults ||\n     desired['wd-no-defaults']) {\n    // no default or appium caps, we dont default\n    delete _desired.wdNoDefaults;\n    delete _desired['wd-no-defaults'];\n  } else {\n    // using default\n    _.defaults(_desired, this.defaultCapabilities);\n  }\n\n  // http options\n  var httpOpts = httpUtils.newHttpOpts('POST', _this._httpConfig);\n\n  var url = httpUtils.buildInitUrl(this.configUrl);\n\n  // building request\n  var data = {desiredCapabilities: _desired};\n\n  httpUtils.emit(this, httpOpts.method, url, data);\n\n  httpOpts.prepareToSend(url, data);\n\n  httpUtils.requestWithRetry(httpOpts, this._httpConfig, this.emit.bind(this), function(err, res, data) {\n    if(err) { return cb(err); }\n\n    var resData;\n    // retrieving session\n    try{\n      var jsonData = JSON.parse(data);\n      if( jsonData.status === 0 ){\n        _this.sessionID = jsonData.sessionId;\n        resData = jsonData.value;\n      }\n    } catch(ignore){}\n    if(!_this.sessionID){\n      // attempting to retrieve the session the old way\n      try{\n        var locationArr = res.headers.location.replace(/\\/$/, '').split('/');\n        _this.sessionID = locationArr[locationArr.length - 1];\n      } catch(ignore){}\n    }\n\n    if (_this.sessionID) {\n      if (/saucelabs\\.com/.exec(url.hostname)) {\n        _this.emit('status', '\\nDriving the web on session: ' + _this.sauceTestPageRoot + '/' + _this.sessionID + '\\n');\n      } else {\n        _this.emit('status', '\\nDriving the web on session: ' + _this.sessionID + '\\n');\n      }\n      if (cb) { cb(null, _this.sessionID, resData); }\n    } else {\n      data = strip(data);\n      if (cb) {\n        err = new Error('The environment you requested was unavailable.');\n        err.data = data;\n        return cb(err);\n      } else {\n        console.error('\\x1b[31mError\\x1b[0m: The environment you requested was unavailable.\\n');\n        console.error('\\x1b[33mReason\\x1b[0m:\\n');\n        console.error(data);\n        console.error('\\nFor the available values please consult the WebDriver JSONWireProtocol,');\n        console.error('located at: \\x1b[33mhttp://code.google.com/p/selenium/wiki/JsonWireProtocol#/session\\x1b[0m');\n      }\n    }\n  });\n};\n\n// standard jsonwire call\nWebdriver.prototype._jsonWireCall = function(opts) {\n  var _this = this;\n\n  // http options init\n  var httpOpts = httpUtils.newHttpOpts(opts.method, this._httpConfig);\n\n  var url = httpUtils.buildJsonCallUrl(this.noAuthConfigUrl, this.sessionID, opts.relPath, opts.absPath);\n\n  // building callback\n  var cb = opts.cb;\n  if (opts.emit) {\n    // wrapping cb if we need to emit a message\n    var _cb = cb;\n    cb = function() {\n      var args = __slice.call(arguments, 0);\n      _this.emit(opts.emit.event, opts.emit.message);\n      if (_cb) { _cb.apply(_this,args); }\n    };\n  }\n\n  // logging\n  httpUtils.emit(this, httpOpts.method, url, opts.data);\n\n  // writting data\n  var data = opts.data || {};\n  httpOpts.prepareToSend(url, data);\n  // building request\n  httpUtils.requestWithRetry(httpOpts, this._httpConfig, this.emit.bind(this), function(err, res, data) {\n    if(err) { return cb(err); }\n    data = strip(data);\n    cb(null, data || \"\");\n  });\n};\n\nWebdriver.prototype._sauceJobUpdate = function(jsonData, done) {\n  var _this = this;\n  if(!this.configUrl || !this.configUrl.auth){\n    return done(new Error(\"Missing auth token.\"));\n  } else if(!this.configUrl.auth.match(/^.+:.+$/)){\n    return done(new Error(\"Invalid auth token.\"));\n  }\n  var jobUpdateUrl = url.resolve(\n    this.sauceRestRoot.replace(/\\/?$/,'/'),\n    this.configUrl.auth.replace(/:.*$/,'') + '/jobs/' + this.sessionID);\n\n  var httpOpts = httpUtils.newHttpOpts('PUT', this._httpConfig);\n  httpOpts.auth = {\n    user: this.configUrl.auth.split(':')[0],\n    pass: this.configUrl.auth.split(':')[1],\n  };\n  httpOpts.jar = false; // disable cookies: avoids CSRF issues\n  httpOpts.prepareToSend(jobUpdateUrl, jsonData);\n\n  httpUtils.requestWithoutRetry(httpOpts, this.emit.bind(this), function(err, resp) {\n    if(err) { return done(err); }\n    if(resp.statusCode !== 200) {\n      return done(new Error(\"Sauce job update failed with http status code:\" +\n        resp.statusCode));\n    }\n    httpUtils.emit(_this, 'POST', '/rest/v1/:user/jobs/:sessionID', jsonData);\n    done();\n  });\n};\n\n_(commands).each(function(fn, name) {\n  Webdriver.prototype[name] = function() {\n    var _this = this;\n    var fargs = utils.varargs(arguments);\n    this.emit('command', \"CALL\" , name + niceArgs(fargs.all));\n    var cb = function(err) {\n      if(err) {\n        err.message = '[' + name + niceArgs(fargs.all) + \"] \" + err.message;\n        if(fargs.callback) { fargs.callback(err); }\n      } else {\n        var cbArgs = __slice.call(arguments, 0);\n        _this.emit('command', \"RESPONSE\" , name + niceArgs(fargs.all),\n          niceResp(_.drop(cbArgs)));\n        if(fargs.callback) { fargs.callback.apply(null, cbArgs); }\n      }\n    };\n    var args = fargs.all.concat([cb]);\n    return fn.apply(this, args);\n  };\n});\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/lodash.js":"var _  = require('lodash');\n_.str = require('underscore.string');\n_.mixin(_.str.exports());\n\n_.mixin({\n    includeString: _.str.include,\n    reverseString: _.str.reverse\n});\n\nmodule.exports = _;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/utils.js":"var Args = require(\"vargs\").Constructor,\n    _ = require('./lodash'),\n    url = require('url'),\n    JSONWIRE_ERRORS = require('./jsonwire-errors.js');\n\nvar varargs = exports.varargs = function(args) {\n  var fargs = new(Args)(args);\n  // returning undefined instead of empty callback\n  fargs.callback = fargs.callbackGiven()? fargs.callback : undefined;\n  return fargs;\n};\n\n// small helper to make sure we don't loose exceptions\n// use this instead of looking  the last argument manually\nexports.findCallback = function(_arguments){\n  var fargs = varargs(_arguments);\n  return fargs.callback;\n};\n\n// convert to type to something like ById, ByCssSelector, etc...\nvar STRAT_MAPPING = {\n  '-ios uiautomation': 'ByIosUIAutomation',\n  '-android uiautomator': 'ByAndroidUIAutomator'\n};\nexports.elFuncSuffix = function(type){\n  var suffix = STRAT_MAPPING[type];\n  if(!suffix) {\n    suffix = (' by ' + type).replace(/(\\s[a-z])/g,\n      function($1){return $1.toUpperCase().replace(' ','');})\n      .replace('Xpath', 'XPath');\n  }\n  return suffix;\n};\n\n// return correct jsonwire type\nexports.elFuncFullType = function(type){\n  if(type === 'css') {return 'css selector'; } // shortcut for css\n  return type;\n};\n\n// from JsonWire spec + shortcuts + mobile JsonWire spec\nexports.elementFuncTypes = ['class name', 'css selector','id','name','link text',\n  'partial link text','tag name', 'xpath', 'css', '-ios uiautomation', '-android uiautomator', 'accessibility id'];\n\n// chai-as-promised promisifier\n// just adding the core method for the sake of safety.\\\n// if you need more than that, build your custom promisifier\nvar Q_CORE_METHODS = [\n    // core methods:\n     \"then\", \"catch\", \"fail\", \"progress\", \"finally\", \"fin\", \"done\",\n     \"thenResolve\", \"thenReject\", \"nodeify\"\n];\n\nexports.transferPromiseness = function(assertion, promise) {\n    _(Q_CORE_METHODS).each(function(methodName) {\n      if (promise[methodName]) {\n        if(assertion._obj) {\n          assertion._obj[methodName] = promise[methodName].bind(promise);\n        }\n        assertion[methodName] = promise[methodName].bind(promise);\n      }\n  });\n  if(promise._enrich) {\n    if(assertion._obj) {\n      promise._enrich(assertion._obj);\n    }\n    promise._enrich(assertion);\n  }\n};\n\n// promise detection\nexports.isPromise = function(x) {\n  return (typeof x === \"object\" || typeof x === \"function\") && x !== null && typeof x.then === \"function\";\n};\n\nexports.deprecator = {\n  deprecationMessageShown: {},\n  warnDeprecated: true,\n  showHideDeprecation: function(status) {\n    if(status !== undefined) { this.warnDeprecated = status; }\n    else { this.warnDeprecated = !this.warnDeprecated; }\n  },\n  warn: function(cat, message) {\n    if(this.warnDeprecated && !this.deprecationMessageShown[cat]) {\n      this.deprecationMessageShown[cat] = 1;\n      console.warn(message);\n    }\n  }\n};\n\n// Android doesn't like cariage return\t\t\nexports.inlineJs = function(script) {\t\t\n  return script.replace(/[\\r\\n]/g,'').trim();\t\t\n};\n\nexports.resolveUrl = function(from, to) {\n  if(typeof from === 'object') { from = url.format(from); }\n\n  // making sure the last part of the path doesn't get stripped\n  if(!from.match(/\\/$/)) { from += '/'; }\n\n  return url.parse(url.resolve(from, to));\n};\n\nexports.strip = function strip(str) {\n  if(typeof(str) !== 'string') { return str; }\n  var x = [];\n  _(str.length).times(function(i) {\n    if (str.charCodeAt(i)) {\n      x.push(str.charAt(i));\n    }\n  });\n  return x.join('');\n};\n\nvar trimToLength = function(str, length) {\n  return (str && str.length > length)?\n    str.substring(0,length) + '...' : str;\n};\nexports.trimToLength = trimToLength;\n\nexports.niceArgs = function(args) {\n  return JSON.stringify(args)\n    .replace(/^\\[/, '(')\n    .replace(/\\]$/, ')');\n};\n\nexports.niceResp = function(args) {\n  return JSON.stringify(args)\n    .replace(/^\\[/, '')\n    .replace(/\\]$/, '');\n};\n\n// convert code to string before execution\nexports.codeToString = function(code) {\n  if(typeof code === 'function') {\n    code = 'return (' + code + ').apply(null, arguments);';\n  }\n  return code;\n};\n\nvar MAX_ERROR_LENGTH = 500;\nexports.newError = function(opts)\n{\n  var err = new Error();\n  _.each(opts, function(opt, k) {\n    err[k] = opt;\n  });\n  // nicer error output\n  err.inspect = function() {\n    var jsonStr = JSON.stringify(err);\n    return trimToLength(jsonStr, MAX_ERROR_LENGTH);\n  };\n  return err;\n};\n\nexports.isWebDriverException = function(res) {\n  return res &&\n         res.class &&\n         (res.class.indexOf('WebDriverException') > 0);\n};\n\nexports.getJsonwireError = function(status) {\n  var jsonwireError = JSONWIRE_ERRORS.filter(function(err) {\n    return err.status === status;\n  });\n  return ((jsonwireError.length>0) ? jsonwireError[0] : null);\n};\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/jsonwire-errors.js":"var JSONWIRE_ERRORS = [\n{\n  status: 0,\n  summary:'Success',\n  detail:'The command executed successfully.'}\n, {\n  status: 7,\n  summary:'NoSuchElement',\n  detail:'An element could not be located on the page using the given search parameters.'}\n, {\n  status: 8,\n  summary:'NoSuchFrame',\n  detail:'A request to switch to a frame could not be satisfied because the frame could not be found.'}\n, {\n  status: 9,\n  summary:'UnknownCommand',\n  detail:'The requested resource could not be found, or a request was received using an HTTP method that is not supported by the mapped resource.'}\n, {\n  status: 10,\n  summary:'StaleElementReference',\n  detail:'An element command failed because the referenced element is no longer attached to the DOM.'}\n, {\n  status: 11,\n  summary:'ElementNotVisible',\n  detail:'An element command could not be completed because the element is not visible on the page.'}\n, {\n  status: 12,\n  summary:'InvalidElementState',\n  detail:'An element command could not be completed because the element is in an invalid state (e.g. attempting to click a disabled element).'}\n, {\n  status: 13,\n  summary:'UnknownError',\n  detail:'An unknown server-side error occurred while processing the command.'}\n, {\n  status: 15,\n  summary:'ElementIsNotSelectable',\n  detail:'An attempt was made to select an element that cannot be selected.'}\n, {\n  status: 17,\n  summary:'JavaScriptError',\n  detail:'An error occurred while executing user supplied JavaScript.'}\n, {\n  status: 19,\n  summary:'XPathLookupError',\n  detail:'An error occurred while searching for an element by XPath.'}\n, {\n  status: 21,\n  summary:'Timeout',\n  detail:'An operation did not complete before its timeout expired.'}\n, {\n  status: 23,\n  summary:'NoSuchWindow',\n  detail:'A request to switch to a different window could not be satisfied because the window could not be found.'}\n, {\n  status: 24,\n  summary:'InvalidCookieDomain',\n  detail:'An illegal attempt was made to set a cookie under a different domain than the current page.'}\n, {\n  status: 25,\n  summary:'UnableToSetCookie',\n  detail:'A request to set a cookie\\'s value could not be satisfied.'}\n, {\n  status: 26,\n  summary:'UnexpectedAlertOpen',\n  detail:'A modal dialog was open, blocking this operation'}\n, {\n  status: 27,\n  summary:'NoAlertOpenError',\n  detail:'An attempt was made to operate on a modal dialog when one was not open.'}\n, {\n  status: 28,\n  summary:'ScriptTimeout',\n  detail:'A script did not complete before its timeout expired.'}\n, {\n  status: 29,\n  summary:'InvalidElementCoordinates',\n  detail:'The coordinates provided to an interactions operation are invalid.'}\n, {\n  status: 30,\n  summary:'IMENotAvailable',\n  detail:'IME was not available.'}\n, {\n  status: 31,\n  summary:'IMEEngineActivationFailed',\n  detail:'An IME engine could not be started.'}\n, {\n  status: 32,\n  summary:'InvalidSelector',\n  detail:'Argument was an invalid selector (e.g. XPath/CSS).'}\n];\n\nmodule.exports = JSONWIRE_ERRORS;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/http-utils.js":"var request = require('request'),\n    utils = require(\"./utils\"),\n    urllib = require('url'),\n    packageDotJson = require('../package.json');\n\nexports.buildInitUrl =function(baseUrl)\n{\n  return utils.resolveUrl(baseUrl, 'session');\n};\n\nexports.emit =function(browser ,method, url, data)\n{\n  if (typeof data === 'object') {\n    data = JSON.stringify(data);\n  }\n  if(typeof url === 'string') { url = urllib.parse(url); }\n  browser.emit('http', method,\n    url.path.replace(browser.sessionID, ':sessionID')\n      .replace(browser.configUrl.pathname, ''), data\n    );\n};\n\nexports.buildJsonCallUrl = function(baseUrl ,sessionID, relPath, absPath){\n  var path = ['session'];\n  if(sessionID)\n    { path.push('/' , sessionID); }\n  if(relPath)\n    { path.push(relPath); }\n  if(absPath)\n    { path = [absPath]; }\n  path = path.join('');\n\n  return utils.resolveUrl(baseUrl, path);\n};\n\nexports.newHttpOpts = function(method, httpConfig) {\n  // this._httpConfig\n  var opts = {};\n\n  opts.method = method;\n  opts.headers = {};\n\n  opts.headers.Connection = 'keep-alive';\n  opts.headers['User-Agent'] = 'admc/wd/' + packageDotJson.version;\n  opts.timeout = httpConfig.timeout;\n  if(httpConfig.proxy) { opts.proxy = httpConfig.proxy; }\n  // we need to check method here to cater for PUT and DELETE case\n  if(opts.method === 'GET' || opts.method === 'POST'){\n    opts.followAllRedirects = true;\n    opts.headers.Accept = 'application/json';\n  }\n\n  opts.prepareToSend = function(url, data) {\n    if (typeof data === 'object') {\n      data = JSON.stringify(data);\n    }\n    this.url = url;\n    if (opts.method === 'POST' || opts.method === 'PUT') {\n      this.headers['Content-Type'] = 'application/json; charset=UTF-8';\n      this.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n      this.body = data;\n    }\n  };\n  return opts;\n};\n\nvar shouldRetryOn = function(err) {\n    return err.code === 'ECONNRESET' ||\n        err.code === 'ETIMEDOUT' ||\n        err.code === 'ESOCKETTIMEDOUT' ||\n        err.code === 'EPIPE';\n};\n\nvar requestWithRetry = function(httpOpts, httpConfig, emit, cb, attempts) {\n  request(httpOpts, function(err, res, data) {\n    if(!attempts) { attempts = 1; }\n    if( httpConfig.retries >= 0 &&\n      (httpConfig.retries === 0 || (attempts -1) <= httpConfig.retries) &&\n      err && (shouldRetryOn(err))) {\n      emit('connection', err.code , 'Lost http connection retrying in ' + httpConfig.retryDelay + ' ms.', err);\n      setTimeout(function() {\n        requestWithRetry(httpOpts, httpConfig, emit, cb, attempts + 1 );\n      }, httpConfig.retryDelay);\n    } else {\n      if(err) {\n        emit('connection', err.code, 'Unexpected error.' , err);\n      }\n      cb(err, res, data);\n    }\n  });\n};\nexports.requestWithRetry = requestWithRetry;\n\nvar requestWithoutRetry = function(httpOpts, emit, cb) {\n  request(httpOpts, function(err, res, data) {\n    if(err) {\n      emit('connection', err.code, 'Unexpected error.' , err);\n    }\n    cb(err, res, data);\n  });\n};\nexports.requestWithoutRetry = requestWithoutRetry;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/config.js":"var _ = require('./lodash');\n\nvar httpConfig = {\n  timeout: undefined,\n  retries: 3,\n  retryDelay: 15,\n  baseUrl: undefined,\n  proxy: undefined\n};\n\nfunction _configureHttp(httpConfig, opts) {\n  _(_.keys(httpConfig)).intersection(_.keys(opts)).each(function(key) {\n    switch(key) {\n      case 'timeout':\n        if(opts[key] === 'default') { opts[key] = undefined; }\n      break;\n      case 'retries':\n        if(opts[key] === 'always') { opts[key] = 0; }\n        if(opts[key] === 'never') { opts[key] = -1; }\n      break;\n    }\n    httpConfig[key] = opts[key];\n  }, this);\n}\n\nfunction configureHttp(opts) {\n  _configureHttp(httpConfig, opts);\n}\n\nmodule.exports = {\n  httpConfig: httpConfig,\n  _configureHttp: _configureHttp,\n  configureHttp: configureHttp\n};\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/element.js":"//Element object\n//Wrapper around browser methods\nvar __slice = Array.prototype.slice;\nvar _ = require(\"./lodash\")\n  , utils = require(\"./utils.js\")\n  , niceArgs = utils.niceArgs\n  , niceResp = utils.niceResp\n  , elementCommands = require('./element-commands');\n\nvar Element = function(value, browser) {\n  this.value = value;\n  this.browser = browser;\n\n  if(!value){\n    throw new Error(\"no value passed to Element constructor\");\n  }\n\n  if(!browser){\n    throw new Error(\"no browser passed to Element constructor\");\n  }\n};\n\nElement.prototype.emit = function() {\n  this.browser.emit.apply(this.browser, __slice.call(arguments, 0));\n};\n\nElement.prototype.toString = function () {\n  return String(this.value);\n};\n\nElement.prototype.toJSON = function () {\n  return { ELEMENT: this.value };\n};\n\n_(elementCommands).each(function(fn, name) {\n  Element.prototype[name] = function() {\n    var _this = this;\n    var fargs = utils.varargs(arguments);\n    this.emit('command', \"CALL\" , \"element.\" + name + niceArgs(fargs.all));\n    var cb = function(err) {\n      if(err) {\n        err.message = '[element.' + name + niceArgs(fargs.all) + \"] \" + err.message;\n        fargs.callback(err);\n      } else {\n        var cbArgs = __slice.call(arguments, 0);\n        _this.emit('command', \"RESPONSE\" , \"element.\" + name + niceArgs(fargs.all),\n          niceResp(_.drop(cbArgs)));\n        fargs.callback.apply(null, cbArgs);\n      }\n    };\n    var args = fargs.all.concat([cb]);\n    return fn.apply(this, args);\n  };\n});\n\nmodule.exports = Element;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/element-commands.js":"//Element object\n//Wrapper around browser methods\nvar _ = require(\"./lodash\")\n  , utils = require(\"./utils.js\")\n  , deprecator = utils.deprecator\n  , fs = require(\"fs\"),\n    callbacks = require(\"./callbacks\"),\n    elementCallback = callbacks.elementCallback,\n    elementsCallback = callbacks.elementsCallback,\n    commands = require('./commands');\n  \nvar elementCommands = {};\n\n/**\n * element.type(keys, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/value\n */\nelementCommands.type = function (keys, cb) {\n  commands.type.apply(this.browser, [this, keys, cb]);\n};\n\n/**\n * element.keys(keys, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/value\n */\nelementCommands.keys = function (keys, cb) {\n  commands.keys.apply(this.browser, [keys, cb]);\n};\n\nfunction _isLocalFile(path, cb) {\n  fs.exists(path, function (exists) {\n    if(exists) {\n      fs.lstat(path, function (err, stats) {\n       cb(err, stats.isFile());\n      });\n    } else { cb(null, false); }\n  });\n}\n\n/**\n * Equivalent to the python sendKeys binding. Upload file if\n * a local file is detected, otherwise behaves like type.\n * element.sendKeys(keys, cb) -> cb(err)\n */\nelementCommands.sendKeys = function (keys, cb) {\n  var _this = this;\n  if (!Array.isArray(keys)) {keys = [keys];}\n\n  // ensure all keystrokes are strings to conform to JSONWP\n  _.each(keys, function(key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n\n  var path = keys.join('');\n  _isLocalFile(path, function (err, isLocalFile) {\n    if(err){ return cb(err); }\n    if(isLocalFile) {\n      commands.uploadFile.apply(_this.browser, [path, function (err, distantFilePath) {\n        if(err){ return cb(err); }\n        return commands.type.apply(_this.browser, [_this, distantFilePath, cb]);\n      }]);\n    } else {\n      commands.type.apply(_this.browser, [_this, keys, cb]);\n    }\n  });\n};\n\n/**\n * Equivalent to the python sendKeys binding, but replaces texts instead of keeping original. Upload file if\n * a local file is detected, otherwise behaves like type.\n * element.setText(keys, cb) -> cb(err)\n */\nelementCommands.setText = function (keys, cb) {\n  var _this = this;\n  if (!Array.isArray(keys)) {keys = [keys];}\n\n  // ensure all keystrokes are strings to conform to JSONWP\n  _.each(keys, function(key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n  commands.replace.apply(_this.browser, [_this, keys, cb]);\n};\n\nelementCommands.replaceKeys = function (keys, cb) {\n  deprecator.warn('element.replaceKeys', 'element.replaceKeys has been deprecated, use element.setText instead.');\n  elementCommands.setText.call(this, keys, cb);\n};\n\n/**\n * element.click(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/click\n */\nelementCommands.click = function (cb) {\n  commands.clickElement.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.tap(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/touch/click\n */\nelementCommands.tap = function (cb) {\n  commands.tapElement.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.doubleClick(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/doubleclick\n */\nelementCommands.doubleclick = function(cb) {\n  return commands.moveTo.apply(this.browser, [this, function(err) {\n    if(err) { return cb(err); }\n    commands.doubleclick.apply(this.browser, [cb]);\n  }.bind(this)]);\n};\n\nelementCommands.doubleClick = elementCommands.doubleclick;\n\n/**\n * element.moveTo(xoffset, yoffset, cb) -> cb(err)\n * xoffset and y offset are optional.\n *\n * @jsonWire POST /session/:sessionId/moveto\n */\nelementCommands.moveTo = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      xoffset = fargs.all[0],\n      yoffset = fargs.all[1];\n  commands.moveTo.apply(this.browser, [this,xoffset, yoffset, cb]);\n};\n\n/**\n * element.flick(xoffset, yoffset, speed, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/touch/flick\n */\nelementCommands.flick = function (xoffset, yoffset, speed, cb) {\n  commands.flick.apply(this.browser, [this.value, xoffset, yoffset, speed, cb]);\n};\n\n\n/**\n * element.text(cb) -> cb(err, text)\n *\n * @jsonWire GET /session/:sessionId/element/:id/text\n * @docOrder 2\n */\nelementCommands.text = function (cb) {\n  commands.text.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.textPresent(searchText, cb) -> cb(err, boolean)\n *\n * @jsonWire GET /session/:sessionId/element/:id/text\n * @docOrder 4\n */\nelementCommands.textPresent = function(searchText, cb) {\n  commands.textPresent.apply(this.browser, [searchText, this, cb]);\n};\n\n/**\n * element.getAttribute(attrName, cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/attribute/:name\n * @docOrder 2\n */\nelementCommands.getAttribute = function(name, cb) {\n  commands.getAttribute.apply(this.browser, [this, name, cb]);\n};\n\n/**\n * element.getTagName(cb) -> cb(err, name)\n *\n * @jsonWire GET /session/:sessionId/element/:id/name\n */\nelementCommands.getTagName = function(cb) {\n  commands.getTagName.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.isDisplayed(cb) -> cb(err, displayed)\n *\n * @jsonWire GET /session/:sessionId/element/:id/displayed\n */\nelementCommands.isDisplayed = function(cb) {\n  commands.isDisplayed.apply(this.browser, [this, cb]);\n};\n\nelementCommands.displayed = elementCommands.isDisplayed;\n\n/**\n * element.isSelected(cb) -> cb(err, selected)\n *\n * @jsonWire GET /session/:sessionId/element/:id/selected\n */\nelementCommands.isSelected = function(cb) {\n  commands.isSelected.apply(this.browser, [this, cb]);\n};\n\nelementCommands.selected = elementCommands.isSelected;\n\n/**\n  * element.isEnabled(cb) -> cb(err, enabled)\n  *\n  * @jsonWire GET /session/:sessionId/element/:id/enabled\n  */\nelementCommands.isEnabled = function(cb) {\n  commands.isEnabled.apply(this.browser, [this, cb]);\n};\n\nelementCommands.enabled = elementCommands.isEnabled;\n\n/**\n * isVisible(cb) -> cb(err, boolean)\n */\nelementCommands.isVisible = function(cb) {\n  deprecator.warn('element.isVisible', 'element.isVisible has been deprecated, use element.isDisplayed instead.');\n  commands.isVisible.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.getLocation(cb) -> cb(err, location)\n *\n * @jsonWire GET /session/:sessionId/element/:id/location\n */\nelementCommands.getLocation = function (cb) {\n  commands.getLocation.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.getLocationInView(cb) -> cb(err, location)\n *\n * @jsonWire GET /session/:sessionId/element/:id/location\n */\nelementCommands.getLocationInView = function (cb) {\n  commands.getLocationInView.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.getSize(cb) -> cb(err, size)\n *\n * @jsonWire GET /session/:sessionId/element/:id/size\n */\nelementCommands.getSize = function (cb) {\n  commands.getSize.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.getValue(cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/attribute/:name\n * @docOrder 4\n */\nelementCommands.getValue = function(cb) {\n  commands.getValue.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.getComputedCss(cssProperty , cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/css/:propertyName\n */\nelementCommands.getComputedCss = function(styleName, cb) {\n  commands.getComputedCss.apply(this.browser, [this, styleName, cb]);\n};\n\nelementCommands.getComputedCSS = elementCommands.getComputedCss;\n\n/**\n * element.clear(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/clear\n */\nelementCommands.clear = function(cb) {\n  commands.clear.apply(this.browser, [this, cb]);\n};\n\n/**\n * element.submit(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/submit\n */\nelementCommands.submit = function(cb) {\n  commands.submit.apply(this.browser, [this, cb]);\n};\n\n_.each(utils.elementFuncTypes, function(type) {\n  /**\n   * element.elementByClassName(value, cb) -> cb(err, element)\n   * element.elementByCssSelector(value, cb) -> cb(err, element)\n   * element.elementById(value, cb) -> cb(err, element)\n   * element.elementByName(value, cb) -> cb(err, element)\n   * element.elementByLinkText(value, cb) -> cb(err, element)\n   * element.elementByPartialLinkText(value, cb) -> cb(err, element)\n   * element.elementByTagName(value, cb) -> cb(err, element)\n   * element.elementByXPath(value, cb) -> cb(err, element)\n   * element.elementByCss(value, cb) -> cb(err, element)\n   * element.elementByIosUIAutomation(value, cb) -> cb(err, element)\n   * element.elementByAndroidUIAutomator(value, cb) -> cb(err, element)\n   * element.elementByAccessibilityId(value, cb) -> cb(err, element)\n   *\n   * @jsonWire POST /session/:sessionId/element/:id/element\n   * @docOrder 2\n   */\n  elementCommands['element' + utils.elFuncSuffix(type)] = function(value, cb) {\n    elementCommands.element.apply(this, [utils.elFuncFullType(type), value, cb]);\n  };\n\n  /**\n   * element.elementsByClassName(value, cb) -> cb(err, elements)\n   * element.elementsByCssSelector(value, cb) -> cb(err, elements)\n   * element.elementsById(value, cb) -> cb(err, elements)\n   * element.elementsByName(value, cb) -> cb(err, elements)\n   * element.elementsByLinkText(value, cb) -> cb(err, elements)\n   * element.elementsByPartialLinkText(value, cb) -> cb(err, elements)\n   * element.elementsByTagName(value, cb) -> cb(err, elements)\n   * element.elementsByXPath(value, cb) -> cb(err, elements)\n   * element.elementsByCss(value, cb) -> cb(err, elements)\n   * element.elementsByIosUIAUtomation(value, cb) -> cb(err, elements)\n   * element.elementsByAndroidUIAutomator(value, cb) -> cb(err, elements)\n   * element.elementsByAccessibilityId(value, cb) -> cb(err, elements)\n   *\n   * @jsonWire POST /session/:sessionId/element/:id/elements\n   * @docOrder 2\n   */\n  elementCommands['elements' + utils.elFuncSuffix(type)] = function(value, cb) {\n    elementCommands.elements.apply(this, [utils.elFuncFullType(type), value, cb]);\n  };\n});\n\n/**\n * element.element(using, value, cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/element/:id/element\n * @docOrder 1\n */\nelementCommands.element = function(using, value, cb) {\n    var _this = this;\n    this.browser._jsonWireCall({\n      method: 'POST'\n      , relPath: '/element/' + _this.value + '/element'\n      , data: {using: using, value: value}\n      , cb: elementCallback(cb, this.browser)\n    });\n};\n\n/**\n * element.elements(using, value, cb) -> cb(err, elements)\n *\n * @jsonWire POST /session/:sessionId/element/:id/elements\n * @docOrder 1\n */\nelementCommands.elements = function(using, value, cb) {\n    var _this = this;\n    this.browser._jsonWireCall({\n      method: 'POST'\n      , relPath: '/element/' + _this.value + '/elements'\n      , data: {using: using, value: value}\n      , cb: elementsCallback(cb, this.browser)\n    });\n};\n\n/**\n * element.equals(other, cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/equals/:other\n * @docOrder 1\n */\nelementCommands.equals = function(other, cb) {\n  commands.equalsElement.apply(this.browser, [this, other, cb]);\n};\n\n/**\n * element.sleep(ms, cb) -> cb(err)\n */\nelementCommands.sleep = function(ms, cb) {\n  cb = cb || function() {};\n  setTimeout(cb , ms);\n};\n\n/**\n * element.noop(cb) -> cb(err)\n */\nelementCommands.noop = function(cb) {\n  if(cb) { cb(); }\n};\n\n/**\n * element.performMultiAction(actions) -> cb(err, touchStateObjects)\n *\n * @jsonWire POST /session/:sessionId/touch/multi/perform\n */\nelementCommands.performMultiAction = function (actions, cb) {\n  commands.performMultiAction.apply(this.browser, [this, actions, cb]);\n};\n\n/**\n * element.rotate(opts, cb) -> cb(err)\n * opts is like the following:\n * {x: 114, y: 198, duration: 5, radius: 3, rotation: 220, touchCount: 2}\n * \n * @jsonWire POST /session/:sessionId/appium/device/rotate\n */\nelementCommands.rotate = function(opts, cb) {\n    commands.rotateDevice.apply(this.browser, [this, opts, cb]);\n};\n\n/**\n * element.setImmediateValueInApp(value, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/element/:elementId?/value\n */\nelementCommands.setImmediateValueInApp = function(value, cb) {\n    commands.setImmediateValueInApp.apply(this.browser, [this, value, cb]);\n};\n/**\n * element.setImmediateValue(value, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/element/:elementId?/value\n */\nelementCommands.setImmediateValue = elementCommands.setImmediateValueInApp;\n\nmodule.exports = elementCommands;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/callbacks.js":"var utils = require(\"./utils\"),\n    newError = utils.newError,\n    getJsonwireError = utils.getJsonwireError,\n    isWebDriverException = utils.isWebDriverException;\n\nvar cbStub = function() {};\n\n// just calls the callback when there is no result\nexports.simpleCallback = function(cb) {\n  cb = cb || cbStub;\n  return function(err, data) {\n    if(err) { return cb(err); }\n    if((data === '') || (data === 'OK')) {\n      // expected behaviour when not returning JsonWire response\n      cb(null);\n    } else {\n      // looking for JsonWire response\n      var jsonWireRes;\n      try{jsonWireRes = JSON.parse(data);}catch(ign){}\n      if (jsonWireRes && (jsonWireRes.status !== undefined)) {\n        // valid JsonWire response\n        if(jsonWireRes.status === 0) {\n          cb(null);\n        } else {\n          var jsonwireError  = getJsonwireError(jsonWireRes.status);\n          var errorMessage = 'Error response status: ' + jsonWireRes.status;\n          if(jsonwireError) {\n            errorMessage += \", \" + jsonwireError.summary + \" - \" + jsonwireError.detail;\n          }\n          if(jsonWireRes.value && jsonWireRes.value.message) {\n            errorMessage += \" Selenium error: \" + jsonWireRes.value.message;\n          }\n          var error = newError(\n            { message: errorMessage\n              , status:jsonWireRes.status\n              , cause:jsonWireRes });\n          if(jsonwireError){ error['jsonwire-error'] = jsonwireError; }\n          cb(error);\n        }\n      } else {\n        // something wrong\n        cb(newError(\n          {message:'Unexpected data in simpleCallback.', data: jsonWireRes || data}) );\n      }\n    }\n  };\n};\n\n// base for all callback handling data\nvar callbackWithDataBase = function(cb) {\n  cb = cb || cbStub;\n  return function(err, data) {\n    if(err) { return cb(err); }\n    var obj,\n        alertText;\n    try {\n      obj = JSON.parse(data);\n    } catch (e) {\n      return cb(newError({message:'Not JSON response', data:data}));\n    }\n    try {\n        alertText = obj.value.alert.text;\n    } catch (e) {\n        alertText = '';\n    }\n    if (obj.status > 0) {\n      var jsonwireError  = getJsonwireError(obj.status);\n      var errorMessage = 'Error response status: ' + obj.status + \", \" +alertText;\n      if(jsonwireError) {\n        errorMessage += \", \" + jsonwireError.summary + \" - \" + jsonwireError.detail;\n      }\n      if(obj.value && obj.value.message) {\n        errorMessage += \" Selenium error: \" + obj.value.message;\n      }\n      var error = newError(\n        { message: errorMessage\n          , status:obj.status\n          , cause:obj });\n      if(jsonwireError){ error['jsonwire-error'] = jsonwireError; }\n      cb(error);\n    } else {\n      cb(null, obj);\n    }\n  };\n};\n\n// retrieves field value from result\nexports.callbackWithData = function(cb, browser) {\n  cb = cb || cbStub;\n  return callbackWithDataBase(function(err,obj) {\n    if(err) {return cb(err);}\n    if(isWebDriverException(obj.value)) {return cb(newError(\n      {message:obj.value.message,cause:obj.value}));}\n    // we might get a WebElement back as part of executeScript, so let's\n    // check to make sure we convert if necessary to element objects\n    if(obj.value && typeof obj.value.ELEMENT !== \"undefined\") {\n        obj.value = browser.newElement(obj.value.ELEMENT);\n    } else if (Object.prototype.toString.call(obj.value) === \"[object Array]\") {\n        for (var i = 0; i < obj.value.length; i++) {\n            if (obj.value[i] && typeof obj.value[i].ELEMENT !== \"undefined\") {\n                obj.value[i] = browser.newElement(obj.value[i].ELEMENT);\n            }\n        }\n    }\n    cb(null, obj.value);\n  });\n};\n\n// retrieves ONE element\nexports.elementCallback = function(cb, browser) {\n  cb = cb || cbStub;\n  return callbackWithDataBase(function(err, obj) {\n    if(err) {return cb(err);}\n    if(isWebDriverException(obj.value)) {return cb(newError(\n      {message:obj.value.message,cause:obj.value}));}\n    if (!obj.value.ELEMENT) {\n      cb(newError(\n        {message:\"no ELEMENT in response value field.\",cause:obj}));\n    } else {\n      var el = browser.newElement(obj.value.ELEMENT);\n      cb(null, el);\n    }\n  });\n};\n\n// retrieves SEVERAL elements\nexports.elementsCallback = function(cb, browser) {\n  cb = cb || cbStub;\n  return callbackWithDataBase(function(err, obj) {\n    if(err) {return cb(err);}\n    if(isWebDriverException(obj.value)) {return cb(newError(\n      {message:obj.value.message,cause:obj.value}));}\n    if (!Array.isArray(obj.value)) {return cb(newError(\n      {message:\"Response value field is not an Array.\", cause:obj.value}));}\n    var i, elements = [];\n    for (i = 0; i < obj.value.length; i++) {\n      var el = browser.newElement(obj.value[i].ELEMENT);\n      elements.push(el);\n    }\n    cb(null, elements);\n  });\n};\n\n// retrieves ONE or SEVERAL elements\nexports.elementOrElementsCallback = function(cb, browser) {\n  cb = cb || cbStub;\n  return callbackWithDataBase(function(err, obj) {\n    if(err) {return cb(err);}\n    if(isWebDriverException(obj.value)) {return cb(newError(\n      {message:obj.value.message,cause:obj.value}));}\n    var el;\n    if (obj.value.ELEMENT){\n      el = browser.newElement(obj.value.ELEMENT);\n      cb(null, el);\n    } else if (Array.isArray(obj.value)){\n      var i, elements = [];\n      for (i = 0; i < obj.value.length; i++) {\n        el = browser.newElement(obj.value[i].ELEMENT);\n        elements.push(el);\n      }\n      cb(null, elements);\n    } else {\n      cb(newError(\n        {message:\"no element or element array in response value field.\",cause:obj}));\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/commands.js":"var fs = require(\"fs\"),\n    url = require('url'),\n    path = require('path'),\n    tmp = require('./tmp'),\n    _ = require(\"./lodash\"),\n    async = require('async'),\n    __slice = Array.prototype.slice,\n    config = require('./config'),\n    callbacks = require(\"./callbacks\"),\n    callbackWithData = callbacks.callbackWithData,\n    simpleCallback = callbacks.simpleCallback,\n    elementCallback = callbacks.elementCallback,\n    elementsCallback = callbacks.elementsCallback,\n    elementOrElementsCallback = callbacks.elementOrElementsCallback,\n    utils = require(\"./utils\"),\n    findCallback = utils.findCallback,\n    codeToString = utils.codeToString,\n    deprecator = utils.deprecator,\n    asserters = require(\"./asserters\"),\n    Asserter = asserters.Asserter,\n    safeExecuteJsScript = require('../build/safe-execute'),\n    safeExecuteAsyncJsScript = require('../build/safe-execute-async'),\n    _waitForConditionInBrowserJsScript = require('../build/wait-for-cond-in-browser');\n\nvar commands = {};\n\n/**\n * init(desired, cb) -> cb(err, sessionID, capabilities)\n * Initialize the browser. capabilities return may be\n * absent, depending on driver.\n *\n * @jsonWire POST /session\n */\ncommands.init = function() {\n  var args = __slice.call(arguments, 0);\n  this._init.apply(this, args);\n};\n\n/**\n * status(cb) -> cb(err, status)\n *\n * @jsonWire GET /status\n */\ncommands.status = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , absPath: 'status'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * sessions(cb) -> cb(err, sessions)\n *\n * @jsonWire GET /sessions\n */\ncommands.sessions = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , absPath: 'sessions'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * Retrieves the current session id.\n * getSessionId(cb) -> cb(err, sessionId)\n * getSessionId()\n */\ncommands.getSessionId = function() {\n  var cb = findCallback(arguments);\n  if(cb) { cb(null, this.sessionID); }\n  return this.sessionID;\n};\n\ncommands.getSessionID = commands.getSessionId;\n\n/**\n * execute(code, args, cb) -> cb(err, result)\n * execute(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute\n * @docOrder 1\n */\ncommands.execute = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n  code = codeToString(code);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/execute'\n    , cb: callbackWithData(cb, this)\n    , data: {script: code, args: args}\n  });\n};\n\n/**\n * Safely execute script within an eval block, always returning:\n * safeExecute(code, args, cb) -> cb(err, result)\n * safeExecute(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute\n * @docOrder 2\n */\ncommands.safeExecute = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n\n  code = codeToString(code);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/execute'\n    , cb: callbackWithData(cb, this)\n    , data: {script: safeExecuteJsScript, args: [code, args]}\n  });\n};\n\n/**\n * Evaluate expression (using execute):\n * eval(code, cb) -> cb(err, value)\n *\n * @jsonWire POST /session/:sessionId/execute\n */\n(function() {\n  // jshint evil: true\n  commands.eval = function(code) {\n    var cb = findCallback(arguments);\n    code = codeToString(code);\n    code = \"return \" + code + \";\";\n    commands.execute.apply(this, [code, function(err, res) {\n      if(err) {return cb(err);}\n      cb(null, res);\n    }]);\n  };\n})();\n\n/**\n * Safely evaluate expression, always returning  (using safeExecute):\n * safeEval(code, cb) -> cb(err, value)\n *\n * @jsonWire POST /session/:sessionId/execute\n */\ncommands.safeEval = function(code) {\n  var cb = findCallback(arguments);\n  code = codeToString(code);\n  commands.safeExecute.apply(this, [code, function(err, res) {\n    if(err) {return cb(err);}\n    cb(null, res);\n  }]);\n};\n\n/**\n * executeAsync(code, args, cb) -> cb(err, result)\n * executeAsync(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute_async\n */\n  commands.executeAsync = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n\n  code = codeToString(code);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/execute_async'\n    , cb: callbackWithData(cb, this)\n    , data: {script: code, args: args}\n  });\n};\n\n/**\n * Safely execute async script within an eval block, always returning:\n * safeExecuteAsync(code, args, cb) -> cb(err, result)\n * safeExecuteAsync(code, cb) -> cb(err, result)\n * args: script argument array (optional)\n *\n * @jsonWire POST /session/:sessionId/execute_async\n */\ncommands.safeExecuteAsync = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      code = fargs.all[0],\n      args = fargs.all[1] || [];\n\n  code = codeToString(code);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/execute_async'\n    , cb: callbackWithData(cb, this)\n    , data: {script: safeExecuteAsyncJsScript , args: [code, args]}\n  });\n};\n\n/**\n * Alternate strategy to get session capabilities from server session list:\n * altSessionCapabilities(cb) -> cb(err, capabilities)\n *\n * @jsonWire GET /sessions\n */\ncommands.altSessionCapabilities = function() {\n  var cb = findCallback(arguments);\n  var _this = this;\n  // looking for the current session\n  commands.sessions.apply(this, [function(err, sessions) {\n    if(err) {\n      cb(err, sessions);\n    } else {\n      sessions = sessions.filter(function(session) {\n        return session.id === _this.sessionID;\n      });\n      cb(null, sessions[0]? sessions[0].capabilities : 0);\n    }\n  }]);\n};\n\n/**\n * sessionCapabilities(cb) -> cb(err, capabilities)\n *\n * @jsonWire GET /session/:sessionId\n */\ncommands.sessionCapabilities = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    // default url\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * Opens a new window (using Javascript window.open):\n * newWindow(url, name, cb) -> cb(err)\n * newWindow(url, cb) -> cb(err)\n * name: optional window name\n * Window can later be accessed by name with the window method,\n * or by getting the last handle returned by the windowHandles method.\n */\ncommands.newWindow = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      url =  fargs.all[0],\n      name = fargs.all[1];\n  commands.execute.apply(\n    this,\n    [ \"var url=arguments[0], name=arguments[1]; window.open(url, name);\",\n      [url,name] , cb]);\n};\n\n/**\n * close(cb) -> cb(err)\n *\n * @jsonWire DELETE /session/:sessionId/window\n */\ncommands.close = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'DELETE'\n    , relPath: '/window'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * currentContext(cb) -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/context\n */\ncommands.currentContext = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/context'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * context(contextRef, cb) -> cb(err, context)\n *\n * @jsonWire POST /session/:sessionId/context\n */\ncommands.context = function(contextRef) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/context'\n    , cb: simpleCallback(cb)\n    , data: { name: contextRef }\n  });\n};\n\n/**\n * contexts(cb) -> cb(err, handle)\n *\n * @jsonWire GET /session/:sessionId/contexts\n */\ncommands.contexts = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/contexts'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * window(name, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/window\n */\ncommands.window = function(windowRef) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/window'\n    , cb: simpleCallback(cb)\n    , data: { name: windowRef }\n  });\n};\n\n/**\n * frame(frameRef, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/frame\n */\ncommands.frame = function(frameRef) {\n  var cb = findCallback(arguments);\n  // avoid using this, Webdriver seems very buggy\n  // doesn't work at all with chromedriver\n  if(typeof(frameRef) === 'function'){\n    frameRef = null;\n  }\n  if(frameRef !== null && typeof(frameRef.value) !== \"undefined\"){\n    // we have an element object\n    frameRef = {ELEMENT: frameRef.value};\n  }\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/frame'\n    , cb: simpleCallback(cb)\n    , data: { id: frameRef }\n  });\n};\n\n/**\n * windowName(cb) -> cb(err, name)\n */\ncommands.windowName = function() {\n  var cb = findCallback(arguments);\n  // jshint evil: true\n  commands.eval.apply(this, [\"window.name\", cb]);\n};\n\n/**\n * windowHandle(cb) -> cb(err, handle)\n *\n * @jsonWire GET /session/:sessionId/window_handle\n */\ncommands.windowHandle = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/window_handle'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * windowHandles(cb) -> cb(err, arrayOfHandles)\n *\n * @jsonWire GET /session/:sessionId/window_handles\n */\ncommands.windowHandles = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/window_handles'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * getGeoLocation(cb) -> cb(err, geoLocationObj)\n *\n * @jsonWire GET /session/:sessionId/location\n */\ncommands.getGeoLocation = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/location'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * setGeoLocation(lat, lon, alt, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/location\n */\ncommands.setGeoLocation = function(lat, lon, alt) {\n  var cb = findCallback(arguments);\n  if(typeof(alt) === 'function'){\n    alt = 0;\n  }\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/location'\n    , cb: simpleCallback(cb)\n    , data: {location :{latitude: lat, longitude: lon, altitude: alt }}\n  });\n};\n\n/**\n * scroll(xOffset, yOffset, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/touch/scroll\n */\ncommands.scroll = function(xOffset, yOffset) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/touch/scroll'\n    , cb: simpleCallback(cb, this)\n    , data: { xoffset: xOffset, yoffset: yOffset }\n  });\n};\n\n\n/**\n * logTypes(cb) -> cb(err, arrayOfLogTypes)\n *\n * @jsonWire GET /session/:sessionId/log/types\n */\ncommands.logTypes = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/log/types'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * log(logType, cb) -> cb(err, arrayOfLogs)\n *\n * @jsonWire POST /session/:sessionId/log\n */\ncommands.log = function(logType) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/log'\n    , cb: callbackWithData(cb, this)\n    , data: { type: logType }\n  });\n};\n\n/**\n * quit(cb) -> cb(err)\n * Destroy the browser.\n *\n * @jsonWire DELETE /session/:sessionId\n */\ncommands.quit = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'DELETE'\n    // default url\n    , emit: {event: 'status', message: '\\nEnding your web drivage..\\n'}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * get(url,cb) -> cb(err)\n * Get a new url.\n *\n * @jsonWire POST /session/:sessionId/url\n */\ncommands.get = function(_url) {\n  if(this._httpConfig.baseUrl) {_url = url.resolve(this._httpConfig.baseUrl, _url); }\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/url'\n    , data: {'url': _url}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * refresh(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/refresh\n */\ncommands.refresh = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/refresh'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n  * maximize(handle, cb) -> cb(err)\n  *\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/maximize\n */\ncommands.maximize = function(win) {\nvar cb = findCallback(arguments);\nthis._jsonWireCall({\n\tmethod: 'POST'\n\t, relPath: '/window/'+ win + '/maximize'\n\t, cb: simpleCallback(cb)\n\t});\n};\n\n/**\n  * windowSize(handle, width, height, cb) -> cb(err)\n  *\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/size\n */\ncommands.windowSize = function(win, width, height) {\nvar cb = findCallback(arguments);\nthis._jsonWireCall({\n  method: 'POST'\n  , relPath: '/window/'+ win + '/size'\n  , data: {'width':width, 'height':height}\n  , cb: simpleCallback(cb)\n  });\n};\n\n/**\n  * getWindowSize(handle, cb) -> cb(err, size)\n  * getWindowSize(cb) -> cb(err, size)\n  * handle: window handle to get size (optional, default: 'current')\n  *\n  * @jsonWire GET /session/:sessionId/window/:windowHandle/size\n */\ncommands.getWindowSize = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      win = fargs.all[0] || 'current';\nthis._jsonWireCall({\n\tmethod: 'GET'\n\t, relPath: '/window/'+ win + '/size'\n\t, cb: callbackWithData(cb, this)\n\t});\n};\n\n/**\n  * setWindowSize(width, height, handle, cb) -> cb(err)\n  * setWindowSize(width, height, cb) -> cb(err)\n  * width: width in pixels to set size to\n  * height: height in pixels to set size to\n  * handle: window handle to set size for (optional, default: 'current')\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/size\n */\ncommands.setWindowSize = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      width = fargs.all[0],\n      height = fargs.all[1],\n      win = fargs.all[2] || 'current';\nthis._jsonWireCall({\n\tmethod: 'POST'\n\t, relPath: '/window/'+ win + '/size'\n    , cb: simpleCallback(cb)\n    , data: {width: width, height: height}\n\t});\n};\n\n/**\n  * getWindowPosition(handle, cb) -> cb(err, position)\n  * getWindowPosition(cb) -> cb(err, position)\n  * handle: window handle to get position (optional, default: 'current')\n  *\n  * @jsonWire GET /session/:sessionId/window/:windowHandle/position\n */\ncommands.getWindowPosition = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      win = fargs.all[0] || 'current';\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/window/'+ win + '/position'\n    , cb: callbackWithData(cb, this)\n    });\n};\n\n/**\n  * setWindowPosition(x, y, handle, cb) -> cb(err)\n  * setWindowPosition(x, y, cb) -> cb(err)\n  * x: the x-coordinate in pixels to set the window position\n  * y: the y-coordinate in pixels to set the window position\n  * handle: window handle to set position for (optional, default: 'current')\n  * @jsonWire POST /session/:sessionId/window/:windowHandle/position\n */\ncommands.setWindowPosition = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      x = fargs.all[0],\n      y = fargs.all[1],\n      win = fargs.all[2] || 'current';\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/window/'+ win + '/position'\n    , cb: simpleCallback(cb)\n    , data: {x: x, y: y}\n  });\n};\n\n/**\n * forward(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/forward\n */\ncommands.forward = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/forward'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * back(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/back\n */\ncommands.back = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/back'\n    , cb: simpleCallback(cb)\n  });\n};\n\ncommands.setHttpTimeout = function() {\n  deprecator.warn('setHttpTimeout',\n    'setHttpTimeout/setHTTPInactivityTimeout has been deprecated, use configureHttp instead.');\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      ms = fargs.all[0];\n  commands.configureHttp( {timeout: ms}, cb );\n};\n\ncommands.setHTTPInactivityTimeout = commands.setHttpTimeout;\n\n/**\n * configureHttp(opts)\n *\n * opts example:\n * {timeout:60000, retries: 3, 'retryDelay': 15, baseUrl='http://example.com/'}\n * more info in README.\n *\n */\ncommands.configureHttp = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      opts = fargs.all[0];\n  config._configureHttp(this._httpConfig, opts);\n  if(cb) { cb(null); }\n};\n\n/**\n * setImplicitWaitTimeout(ms, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/timeouts/implicit_wait\n */\ncommands.setImplicitWaitTimeout = function(ms) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/timeouts/implicit_wait'\n    , data: {ms: ms}\n    , cb: simpleCallback(cb)\n  });\n};\n\n// for backward compatibility\ncommands.setWaitTimeout = commands.setImplicitWaitTimeout;\n\n/**\n * setAsyncScriptTimeout(ms, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/timeouts/async_script\n */\ncommands.setAsyncScriptTimeout = function(ms) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/timeouts/async_script'\n    , data: {ms: ms}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * setPageLoadTimeout(ms, cb) -> cb(err)\n * (use setImplicitWaitTimeout and setAsyncScriptTimeout to set the other timeouts)\n *\n * @jsonWire POST /session/:sessionId/timeouts\n */\ncommands.setPageLoadTimeout = function(ms) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/timeouts'\n    , data: {type: 'page load', ms: ms}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * setCommandTimeout(ms, cb) -> cb(err)\n * (this is for Appium only)\n * @jsonWire POST /session/:sessionId/timeouts\n */\ncommands.setCommandTimeout = function(ms) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/timeouts'\n    , data: {type: 'command', ms: ms}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * element(using, value, cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/element\n */\ncommands.element = function(using, value) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/element'\n    , data: {using: using, value: value}\n    , cb: elementCallback(cb, this)\n  });\n};\n\n/**\n * Retrieve an element avoiding not found exception and returning null instead:\n * elementOrNull(using, value, cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 3\n */\ncommands.elementOrNull = function(using, value) {\n  var cb = findCallback(arguments);\n  commands.elements.apply(this, [using, value,\n    function(err, elements) {\n      if(!err) {\n        if(elements.length>0) {cb(null,elements[0]);} else {cb(null,null);}\n      } else {\n        cb(err); }\n    }\n  ]);\n};\n\n/**\n * Retrieve an element avoiding not found exception and returning undefined instead:\n * elementIfExists(using, value, cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 5\n */\ncommands.elementIfExists = function(using, value) {\n  var cb = findCallback(arguments);\n  commands.elements.apply(this, [using, value,\n    function(err, elements) {\n      if(!err) {\n        if(elements.length>0) {cb(null,elements[0]);} else {cb(null);}\n      } else {\n        cb(err); }\n    }\n  ]);\n};\n\n/**\n * elements(using, value, cb) -> cb(err, elements)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 1\n */\ncommands.elements = function(using, value) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/elements'\n    , data: {using: using, value: value}\n    , cb: elementsCallback(cb, this)\n  });\n};\n\n/**\n * Check if element exists:\n * hasElement(using, value, cb) -> cb(err, boolean)\n *\n * @jsonWire POST /session/:sessionId/elements\n * @docOrder 7\n */\ncommands.hasElement = function(using, value){\n  var cb = findCallback(arguments);\n  commands.elements.apply( this, [using, value, function(err, elements){\n    if(!err) {\n      cb(null, elements.length > 0 );\n    } else {\n      cb(err); }\n  }]);\n};\n\n/**\n * waitFor(asserter, timeout, pollFreq, cb) -> cb(err, return_value)\n * timeout and pollFreq are optional (default 1000ms/200ms)\n * waitFor(opts, cb) -> cb(err)\n * opts with the following fields: timeout, pollFreq, asserter.\n * asserter like: function(browser , cb) -> cb(err, satisfied, return_value)\n */\ncommands.waitFor = function(){\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var opts;\n  // retrieving options\n  if(typeof fargs.all[0] === 'object' && !(fargs.all[0] instanceof Asserter)){\n    opts = fargs.all[0];\n  } else\n  {\n    opts = {\n      asserter: fargs.all[0],\n      timeout: fargs.all[1],\n      pollFreq: fargs.all[2]\n    };\n  }\n\n  // default\n  opts.timeout = opts.timeout || 1000;\n  opts.pollFreq = opts.pollFreq || 200;\n\n  if(!opts.asserter) { throw new Error('Missing asserter!'); }\n\n  var _this = this;\n  var endTime = Date.now() + opts.timeout;\n\n  var unpromisedAsserter = new Asserter(\n    function(browser, cb) {\n      var promise = opts.asserter.assert(browser, cb);\n      if(promise && promise.then && typeof promise.then === 'function'){\n        promise.then(\n          function(res) { cb(null, true, res); },\n          function(err) {\n            if(err.retriable) { cb(null, false); }\n            else { throw err; }\n          }\n        );\n      }\n    }\n  );\n\n  function poll(isFinalCheck){\n    unpromisedAsserter.assert(_this, function(err, satisfied, value) {\n      if(err) { return cb(err); }\n      if(satisfied) {\n        cb(null, value);\n      } else {\n        if(isFinalCheck) {\n          cb(new Error(\"Condition wasn't satisfied!\"));\n        } else if(Date.now() > endTime){\n          // trying one more time for safety\n          setTimeout(poll.bind(null, true) , opts.pollFreq);\n        } else {\n          setTimeout(poll, opts.pollFreq);\n        }\n      }\n    });\n  }\n\n  poll();\n};\n\n/**\n * waitForElement(using, value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n * waitForElement(using, value, timeout, pollFreq, cb) -> cb(err, el)\n * timeout and pollFreq are optional (default 1000ms/200ms)\n * waitForElement(using, value, opts, cb) -> cb(err, el)\n * opts with the following fields: timeout, pollFreq, asserter.\n * asserter like: function(element , cb) -> cb(err, satisfied, el)\n */\ncommands.waitForElement = function(){\n\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var using = fargs.all[0],\n      value = fargs.all[1];\n  var opts;\n\n  // retrieving options\n  if(typeof fargs.all[2] === 'object' && !(fargs.all[2] instanceof Asserter)){\n    opts = fargs.all[2];\n  } else if(fargs.all[2] instanceof Asserter) {\n    opts = {\n      asserter: fargs.all[2],\n      timeout: fargs.all[3],\n      pollFreq: fargs.all[4]\n    };\n  } else {\n    opts = {\n      timeout: fargs.all[2],\n      pollFreq: fargs.all[3]\n    };\n  }\n\n  // default\n  opts.asserter = opts.asserter || new Asserter(function(el, cb) { cb(null, true); });\n\n  var unpromisedAsserter = new Asserter(\n    function(el, cb) {\n      var promise = opts.asserter.assert(el, cb);\n      if(promise && promise.then && typeof promise.then === 'function'){\n        promise.then(\n          function() { cb(null, true); },\n          function(err) {\n            if(err.retriable) { cb(null, false); }\n            else { throw err; }\n          }\n        );\n      }\n    }\n  );\n\n  var wrappedAsserter = new Asserter(\n    function(browser, cb){\n      browser.elements(using, value, function(err, els){\n        if(err) { return cb(err); }\n        var seq = [];\n        var satisfiedEl;\n        _(els).each(function(el) {\n          seq.push(function(cb) {\n            if(satisfiedEl) { return cb(); }\n            unpromisedAsserter.assert(el, function(err, satisfied) {\n              if(err) { return cb(err); }\n              if(satisfied) { satisfiedEl = el; }\n              cb(err);\n            });\n          });\n        });\n        async.series(seq, function(err) {\n            if(err) { return cb(err); }\n            cb(err, !_.isUndefined(satisfiedEl)  , satisfiedEl);\n        });\n      });\n    }\n  );\n\n  commands.waitFor.apply(this,[\n    {\n      asserter: wrappedAsserter,\n      timeout: opts.timeout,\n      pollFreq: opts.pollFreq\n    }, function(err, value) {\n      if(err && err.message && err.message.match(/Condition/)) {\n        cb(new Error(\"Element condition wasn't satisfied!\"));\n      } else {\n        cb(err, value);\n      }\n    }]);\n};\n\n/**\n * waitForElements(using, value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n * waitForElements(using, value, timeout, pollFreq, cb) -> cb(err, els)\n * timeout and pollFreq are optional (default 1000ms/200ms)\n * waitForElements(using, value, opts, cb) -> cb(err, els)\n * opts with the following fields: timeout, pollFreq, asserter.\n * asserter like: function(element , cb) -> cb(err, satisfied, el)\n */\ncommands.waitForElements = function(){\n\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var using = fargs.all[0],\n      value = fargs.all[1];\n  var opts;\n\n  // retrieving options\n  if(typeof fargs.all[2] === 'object' && !(fargs.all[2] instanceof Asserter)){\n    opts = fargs.all[2];\n  } else if(fargs.all[2] instanceof Asserter) {\n    opts = {\n      asserter: fargs.all[2],\n      timeout: fargs.all[3],\n      pollFreq: fargs.all[4]\n    };\n  } else {\n    opts = {\n      timeout: fargs.all[2],\n      pollFreq: fargs.all[3]\n    };\n  }\n\n  // default\n  opts.asserter = opts.asserter || new Asserter(function(el, cb) { cb(null, true); });\n\n  var unpromisedAsserter = new Asserter(\n    function(el, cb) {\n      var promise = opts.asserter.assert(el, cb);\n      if(promise && promise.then && typeof promise.then === 'function'){\n        promise.then(\n          function() { cb(null, true); },\n          function(err) {\n            if(err.retriable) { cb(null, false); }\n            else { throw err; }\n          }\n        );\n      }\n    }\n  );\n\n  var wrappedAsserter = new Asserter(\n    function(browser, cb){\n      browser.elements(using, value, function(err, els){\n        if(err) { return cb(err); }\n        var seq = [];\n        var satisfiedEls = [];\n        _(els).each(function(el) {\n          seq.push(function(cb) {\n            unpromisedAsserter.assert(el, function(err, satisfied) {\n              if(err) { return cb(err); }\n              if(satisfied) { satisfiedEls.push(el); }\n              cb(err);\n            });\n          });\n        });\n        async.series(seq, function(err) {\n            if(err) { return cb(err); }\n            cb(err, satisfiedEls.length > 0  , satisfiedEls);\n        });\n      });\n    }\n  );\n\n  commands.waitFor.apply(this,[\n    {\n      asserter: wrappedAsserter,\n      timeout: opts.timeout,\n      pollFreq: opts.pollFreq\n    }, function(err, value) {\n      if(err && err.message && err.message.match(/Condition/)) {\n        cb(new Error(\"Element condition wasn't satisfied!\"));\n      } else {\n        cb(err, value);\n      }\n    }]);\n};\n\ncommands.waitForVisible = function(using, value, timeout, pollFreq) {\n  deprecator.warn('waitForVisible',\n    'waitForVisible has been deprecated, use waitForElement + isVisible asserter instead.');\n\n  var cb = findCallback(arguments);\n\n  commands.waitForElement.apply(this, [using, value, asserters.isVisible, timeout, pollFreq, function(err, isVisible) {\n    if(err && err.message && err.message.match(/Element condition wasn't satisfied!/)){\n      cb(new Error(\"Element didn't become visible\"));\n    } else {\n      cb(err, isVisible);\n    }\n  }]);\n};\n\n/**\n * takeScreenshot(cb) -> cb(err, screenshot)\n *\n * @jsonWire GET /session/:sessionId/screenshot\n */\ncommands.takeScreenshot = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/screenshot'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * saveScreenshot(path, cb) -> cb(err, filePath)\n *\n * path maybe a full file path, a directory path (finishing with /),\n * the screenshot name, or left blank (will create a file in the system temp dir).\n */\ncommands.saveScreenshot = function() {\n  var _this = this;\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var _path = fargs.all[0];\n\n  function buildFilePath(_path, cb) {\n    if(!_path) { _path = tmp.tmpdir + '/'; }\n    if(_path.match(/.*\\/$/)) {\n      tmp.tmpName( {template: 'screenshot-XXXXXX.png'}, function(err, fileName) {\n        if(err) { return cb(err); }\n        cb(null, path.join( _path , fileName) );\n      });\n    } else {\n      if(path.extname(_path) === '') { _path = _path + '.png'; }\n      cb(null, _path);\n    }\n  }\n\n  buildFilePath(_path, function(err, filePath) {\n    commands.takeScreenshot.apply(_this, [function(err, base64Data) {\n      if(err) { return cb(err); }\n      require(\"fs\").writeFile(filePath, base64Data, 'base64', function(err) {\n        if(err) { return cb(err); }\n        cb(null, filePath);\n      });\n    }]);\n  });\n};\n\n// adding all elementBy... , elementsBy... function\n\nvar addMethodsForSuffix = function(type, singular, plural) {\n  if(singular){\n    /**\n     * elementByClassName(value, cb) -> cb(err, element)\n     * elementByCssSelector(value, cb) -> cb(err, element)\n     * elementById(value, cb) -> cb(err, element)\n     * elementByName(value, cb) -> cb(err, element)\n     * elementByLinkText(value, cb) -> cb(err, element)\n     * elementByPartialLinkText(value, cb) -> cb(err, element)\n     * elementByTagName(value, cb) -> cb(err, element)\n     * elementByXPath(value, cb) -> cb(err, element)\n     * elementByCss(value, cb) -> cb(err, element)\n     * elementByIosUIAutomation(value, cb) -> cb(err, element)\n     * elementByAndroidUIAutomator(value, cb) -> cb(err, element)\n     * elementByAccessibilityId(value, cb) -> cb(err, element)\n     *\n     * @jsonWire POST /session/:sessionId/element\n     */\n    commands['element' + utils.elFuncSuffix(type)] = function() {\n      var args = __slice.call(arguments, 0);\n      args.unshift(utils.elFuncFullType(type));\n      commands.element.apply(this, args);\n    };\n\n    /**\n     * elementByClassNameOrNull(value, cb) -> cb(err, element)\n     * elementByCssSelectorOrNull(value, cb) -> cb(err, element)\n     * elementByIdOrNull(value, cb) -> cb(err, element)\n     * elementByNameOrNull(value, cb) -> cb(err, element)\n     * elementByLinkTextOrNull(value, cb) -> cb(err, element)\n     * elementByPartialLinkTextOrNull(value, cb) -> cb(err, element)\n     * elementByTagNameOrNull(value, cb) -> cb(err, element)\n     * elementByXPathOrNull(value, cb) -> cb(err, element)\n     * elementByCssOrNull(value, cb) -> cb(err, element)\n     * elementByIosUIAutomationOrNull(value, cb) -> cb(err, element)\n     * elementByAndroidUIAutomatorOrNull(value, cb) -> cb(err, element)\n     * elementByAccessibilityIdOrNull(value, cb) -> cb(err, element)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 4\n     */\n    commands['element' + utils.elFuncSuffix(type)+ 'OrNull'] = function() {\n      var fargs = utils.varargs(arguments);\n      var cb = fargs.callback;\n      var args = fargs.all;\n      args.unshift(utils.elFuncFullType(type));\n      args.push(\n        function(err, elements) {\n          if(!err) {\n            if(elements.length>0) {cb(null,elements[0]);} else {cb(null,null);}\n          } else {\n            cb(err);\n          }\n        }\n      );\n      commands.elements.apply(this, args );\n    };\n\n    /**\n     * elementByClassNameIfExists(value, cb) -> cb(err, element)\n     * elementByCssSelectorIfExists(value, cb) -> cb(err, element)\n     * elementByIdIfExists(value, cb) -> cb(err, element)\n     * elementByNameIfExists(value, cb) -> cb(err, element)\n     * elementByLinkTextIfExists(value, cb) -> cb(err, element)\n     * elementByPartialLinkTextIfExists(value, cb) -> cb(err, element)\n     * elementByTagNameIfExists(value, cb) -> cb(err, element)\n     * elementByXPathIfExists(value, cb) -> cb(err, element)\n     * elementByCssIfExists(value, cb) -> cb(err, element)\n     * elementByIosUIAutomationIfExists(value, cb) -> cb(err, element)\n     * elementByAndroidUIAutomatorIfExists(value, cb) -> cb(err, element)\n     * elementByAccessibilityIdIfExists(value, cb) -> cb(err, element)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 6\n     */\n    commands['element' + utils.elFuncSuffix(type)+ 'IfExists'] = function() {\n      var fargs = utils.varargs(arguments);\n      var cb = fargs.callback;\n      var args = fargs.all;\n      args.unshift(utils.elFuncFullType(type));\n      args.push(\n        function(err, elements) {\n          if(!err) {\n            if(elements.length>0) {cb(null,elements[0]);} else {cb(null);}\n          } else {\n            cb(err); }\n        }\n      );\n      commands.elements.apply(this, args);\n    };\n\n    /**\n     * hasElementByClassName(value, cb) -> cb(err, boolean)\n     * hasElementByCssSelector(value, cb) -> cb(err, boolean)\n     * hasElementById(value, cb) -> cb(err, boolean)\n     * hasElementByName(value, cb) -> cb(err, boolean)\n     * hasElementByLinkText(value, cb) -> cb(err, boolean)\n     * hasElementByPartialLinkText(value, cb) -> cb(err, boolean)\n     * hasElementByTagName(value, cb) -> cb(err, boolean)\n     * hasElementByXPath(value, cb) -> cb(err, boolean)\n     * hasElementByCss(value, cb) -> cb(err, boolean)\n     * hasElementByIosUIAutomation(value, cb) -> cb(err, boolean)\n     * hasElementByAndroidUIAutomator(value, cb) -> cb(err, boolean)\n     * hasElementByAccessibilityId(value, cb) -> cb(err, boolean)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 8\n     */\n    commands['hasElement' + utils.elFuncSuffix(type)] = function() {\n      var args = __slice.call(arguments, 0);\n      args.unshift(utils.elFuncFullType(type));\n      commands.hasElement.apply(this, args);\n    };\n\n    /**\n     * waitForElementByClassName(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByCssSelector(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementById(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByName(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByPartialLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByTagName(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByXPath(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByCss(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByIosUIAutomation(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByAndroidUIAutomator(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementByAccessibilityId(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * asserter, timeout, pollFreq are optional, opts may be passed instead,\n     * as in waitForElement.\n     */\n    commands['waitForElement' + utils.elFuncSuffix(type)] = function() {\n      var args = __slice.call(arguments, 0);\n      args.unshift(utils.elFuncFullType(type));\n      commands.waitForElement.apply(this, args);\n    };\n\n    /**\n     * waitForElementsByClassName(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByCssSelector(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsById(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByName(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByPartialLinkText(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByTagName(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByXPath(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByCss(value, asserter, timeout, pollFreq, cb) -> cb(err, els)\n     * waitForElementsByIosUIAutomation(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementsByAndroidUIAutomator(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * waitForElementsByAccessibilityId(value, asserter, timeout, pollFreq, cb) -> cb(err, el)\n     * asserter, timeout, pollFreq are optional, opts may be passed instead,\n     * as in waitForElements.\n     */\n    commands['waitForElements' + utils.elFuncSuffix(type)] = function() {\n      var args = __slice.call(arguments, 0);\n      args.unshift(utils.elFuncFullType(type));\n      commands.waitForElements.apply(this, args);\n    };\n\n    commands['waitForVisible' + utils.elFuncSuffix(type)] = function() {\n      var args = __slice.call(arguments, 0);\n      args.unshift(utils.elFuncFullType(type));\n      commands.waitForVisible.apply(this, args);\n    };\n\n    /**\n     * elementsByClassName(value, cb) -> cb(err, elements)\n     * elementsByCssSelector(value, cb) -> cb(err, elements)\n     * elementsById(value, cb) -> cb(err, elements)\n     * elementsByName(value, cb) -> cb(err, elements)\n     * elementsByLinkText(value, cb) -> cb(err, elements)\n     * elementsByPartialLinkText(value, cb) -> cb(err, elements)\n     * elementsByTagName(value, cb) -> cb(err, elements)\n     * elementsByXPath(value, cb) -> cb(err, elements)\n     * elementsByCss(value, cb) -> cb(err, elements)\n     * elementsByIosUIAutomation(value, cb) -> cb(err, elements)\n     * elementsByAndroidUIAutomator(value, cb) -> cb(err, elements)\n     * elementsByAccessibilityId(value, cb) -> cb(err, elements)\n     *\n     * @jsonWire POST /session/:sessionId/elements\n     * @docOrder 2\n     */\n  }\n  if(plural){\n    commands['elements' + utils.elFuncSuffix(type)] = function() {\n      var args = __slice.call(arguments, 0);\n      args.unshift(utils.elFuncFullType(type));\n      commands.elements.apply(this, args);\n    };\n  }\n};\n\n_.each(utils.elementFuncTypes, function(suffix) {\n  addMethodsForSuffix(suffix, true, true);\n});\n\n/**\n * getTagName(element, cb) -> cb(err, name)\n *\n * @jsonWire GET /session/:sessionId/element/:id/name\n */\ncommands.getTagName = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/name'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * getAttribute(element, attrName, cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/attribute/:name\n * @docOrder 1\n */\ncommands.getAttribute = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      attrName = fargs.all[1];\n  if(!element) { throw new Error('Missing element.'); }\n  if(!attrName) { throw new Error('Missing attribute name.'); }\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/attribute/' + attrName\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * isDisplayed(element, cb) -> cb(err, displayed)\n *\n * @jsonWire GET /session/:sessionId/element/:id/displayed\n */\ncommands.isDisplayed = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/displayed'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\ncommands.displayed = commands.isDisplayed;\n\n/**\n  * isEnabled(element, cb) -> cb(err, enabled)\n  *\n  * @jsonWire GET /session/:sessionId/element/:id/enabled\n  */\ncommands.isEnabled = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/enabled'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\ncommands.enabled = commands.isEnabled;\n\n/**\n * isSelected(element, cb) -> cb(err, selected)\n *\n * @jsonWire GET /session/:sessionId/element/:id/selected\n */\ncommands.isSelected = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/selected'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n// commands.selected = commands.isSelected;\n\n/**\n * Get element value (in value attribute):\n * getValue(element, cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/attribute/:name\n * @docOrder 3\n */\ncommands.getValue = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0];\n  if(!element) { throw new Error('Missing element.'); }\n  commands.getAttribute.apply(this, [element, 'value', cb]);\n};\n\n/**\n * clickElement(element, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/click\n */\ncommands.clickElement = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/element/' + element + '/click'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * getComputedCss(element, cssProperty , cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/css/:propertyName\n */\ncommands.getComputedCss = function(element, cssProperty) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/css/' + cssProperty\n    , cb: callbackWithData(cb, this)\n  });\n};\n\ncommands.getComputedCSS = commands.getComputedCss;\n\n/**\n * equalsElement(element, other , cb) -> cb(err, value)\n *\n * @jsonWire GET /session/:sessionId/element/:id/equals/:other\n */\ncommands.equalsElement = function(element, other) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/equals/' + other\n    , cb: callbackWithData(cb, this)\n  });\n};\n\nvar _flick1 = function(){\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      xspeed = fargs.all[0],\n      yspeed = fargs.all[1],\n      swipe = fargs.all[2];\n\n  var data = { xspeed: xspeed, yspeed: yspeed };\n  if (swipe) {\n    data.swipe = swipe;\n  }\n\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/touch/flick'\n    , data: data\n    , cb: simpleCallback(cb)\n  });\n};\n\nvar _flick2 = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      xoffset = fargs.all[1],\n      yoffset = fargs.all[2],\n      speed = fargs.all[3];\n\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/touch/flick'\n    , data: { element: element, xoffset: xoffset, yoffset: yoffset, speed: speed }\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * flick(xSpeed, ySpeed, swipe, cb) -> cb(err)\n * Flicks, starting anywhere on the screen.\n *\n * flick(element, xoffset, yoffset, speed, cb) -> cb(err)\n * Flicks, starting at element center.\n *\n * @jsonWire POST /session/:sessionId/touch/flick\n */\ncommands.flick = function() {\n  var args = __slice.call(arguments, 0);\n  if (args.length <= 4) {\n    _flick1.apply(this, args);\n  } else {\n    _flick2.apply(this, args);\n  }\n};\n\n/**\n * tapElement(element) -> cb(err)\n * Taps element\n *\n * @jsonWire POST /session/:sessionId/touch/click\n */\ncommands.tapElement = function(element, cb) {\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/touch/click'\n    , data: { element: element.value.toString() }\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * performTouchAction(touchAction) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/touch/perform\n */\ncommands.performTouchAction = function () {\n  var _this = this;\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      touchAction = fargs.all[0];\n\n  try {\n    _this._jsonWireCall({\n      method: 'POST',\n      relPath: '/touch/perform',\n      data: {actions: touchAction.toJSON()},\n      cb: callbackWithData(cb, this)\n    });\n  } catch (err) {\n    return cb(err);\n  }\n};\n\n/**\n * performMultiAction(element, multiAction) -> cb(err, touchStateObjects)\n * performMultiAction(multiAction) -> cb(err, touchStateObjects)\n *\n * @jsonWire POST /session/:sessionId/touch/multi/perform\n */\ncommands.performMultiAction = function () {\n  var _this = this;\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      multiTouchAction = fargs.all[1];\n  if(!multiTouchAction) {\n    multiTouchAction = element;\n    element = null;\n  }\n  element =  element || multiTouchAction.element;\n  try {\n    var data = multiTouchAction.toJSON(element);\n    if(element) { data.elementId = element.value.toString(); }\n    _this._jsonWireCall({\n      method: 'POST',\n      relPath: '/touch/multi/perform',\n      data: data,\n      cb: callbackWithData(cb, this)\n    });\n  } catch (err) {\n    return cb(err);\n  }\n};\n\n/**\n * moveTo(element, xoffset, yoffset, cb) -> cb(err)\n * Move to element, element may be null, xoffset and y offset\n * are optional.\n *\n * @jsonWire POST /session/:sessionId/moveto\n */\ncommands.moveTo = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      xoffset = fargs.all[1],\n      yoffset = fargs.all[2];\n\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/moveto'\n    , data: { element:\n      element? element.toString(): null,\n      xoffset: xoffset,\n      yoffset: yoffset }\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * buttonDown(button ,cb) -> cb(err)\n * button is optional.\n * {LEFT = 0, MIDDLE = 1 , RIGHT = 2}.\n * LEFT if not specified.\n *\n * @jsonWire POST /session/:sessionId/buttondown\n */\ncommands.buttonDown = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      button = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/buttondown'\n    , data: {button: button}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * buttonUp(button, cb) -> cb(err)\n * button is optional.\n * {LEFT = 0, MIDDLE = 1 , RIGHT = 2}.\n * LEFT if not specified.\n *\n * @jsonWire POST /session/:sessionId/buttonup\n */\ncommands.buttonUp = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      button = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/buttonup'\n    , data: {button: button}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * click(button, cb) -> cb(err)\n * Click on current element.\n * Buttons: {left: 0, middle: 1 , right: 2}\n *\n * @jsonWire POST /session/:sessionId/click\n */\ncommands.click = function() {\n  // parsing args, button optional\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      button = fargs.all[0];\n\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/click'\n    , data: {button: button}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * doubleclick(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/doubleclick\n */\ncommands.doubleclick = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/doubleclick'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * type(element, keys, cb) -> cb(err)\n * Type keys (all keys are up at the end of command).\n * special key map: wd.SPECIAL_KEYS (see lib/special-keys.js)\n *\n * @jsonWire POST /session/:sessionId/element/:id/value\n */\ncommands.type = function(element, keys) {\n  var cb = findCallback(arguments);\n  if (!Array.isArray(keys)) {keys = [keys];}\n  // ensure all keystrokes are strings to conform to JSONWP\n  _.each(keys, function(key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/element/' + element + '/value'\n    , data: {value: keys}\n    , cb: simpleCallback(cb)\n  });\n};\n\ncommands.replace = function(element, keys) {\n  var cb = findCallback(arguments);\n  if (!Array.isArray(keys)) {keys = [keys];}\n  // ensure all keystrokes are strings to conform to JSONWP\n  _.each(keys, function(key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/element/' + element + '/replace_value'\n    , data: {value: keys}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * submit(element, cb) -> cb(err)\n * Submit a `FORM` element.\n *\n * @jsonWire POST /session/:sessionId/element/:id/submit\n */\ncommands.submit = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/element/' + element + '/submit'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * keys(keys, cb) -> cb(err)\n * Press keys (keys may still be down at the end of command).\n * special key map: wd.SPECIAL_KEYS (see lib/special-keys.js)\n *\n * @jsonWire POST /session/:sessionId/keys\n */\ncommands.keys = function(keys) {\n  var cb = findCallback(arguments);\n  if (!Array.isArray(keys)) {keys = [keys];}\n  // ensure all keystrokes are strings to conform to JSONWP\n  _.each(keys, function(key, idx) {\n    if (typeof key !== \"string\") {\n      keys[idx] = key.toString();\n    }\n  });\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/keys'\n    , data: {value: keys}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * clear(element, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/element/:id/clear\n */\ncommands.clear = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/element/' + element + '/clear'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * title(cb) -> cb(err, title)\n *\n * @jsonWire GET /session/:sessionId/title\n */\ncommands.title = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/title'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * source(cb) -> cb(err, source)\n *\n * @jsonWire GET /session/:sessionId/source\n */\ncommands.source = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n\t\tmethod: 'GET'\n\t\t, relPath: '/source'\n\t\t, cb: callbackWithData(cb, this)\n\t});\n};\n\n// element must be specified\nvar _rawText = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/text'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * text(element, cb) -> cb(err, text)\n * element: specific element, 'body', or undefined\n *\n * @jsonWire GET /session/:sessionId/element/:id/text\n * @docOrder 1\n */\ncommands.text = function() {\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var element = fargs.all[0];\n  var _this = this;\n  if (!element || element === 'body') {\n    commands.element.apply(this, ['tag name', 'body', function(err, bodyEl) {\n      if (!err) {_rawText.apply(_this, [bodyEl, cb]);} else {cb(err);}\n    }]);\n  }else {\n    _rawText.apply(_this, [element, cb]);\n  }\n};\n\n/**\n * Check if text is present:\n * textPresent(searchText, element, cb) -> cb(err, boolean)\n * element: specific element, 'body', or undefined\n *\n * @jsonWire GET /session/:sessionId/element/:id/text\n * @docOrder 3\n */\ncommands.textPresent = function(searchText, element) {\n  var cb = findCallback(arguments);\n  commands.text.apply(this, [element, function(err, text) {\n    if (err) {\n      cb(err, null);\n    } else {\n      cb(err, text.indexOf(searchText) >= 0);\n    }\n  }]);\n};\n\n/**\n * alertText(cb) -> cb(err, text)\n *\n * @jsonWire GET /session/:sessionId/alert_text\n */\ncommands.alertText = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/alert_text'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * alertKeys(keys, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/alert_text\n */\ncommands.alertKeys = function(keys) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/alert_text'\n    , data: {text: keys}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * acceptAlert(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/accept_alert\n */\ncommands.acceptAlert = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/accept_alert'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * dismissAlert(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/dismiss_alert\n */\ncommands.dismissAlert = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/dismiss_alert'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * active(cb) -> cb(err, element)\n *\n * @jsonWire POST /session/:sessionId/element/active\n */\ncommands.active = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/element/active'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * url(cb) -> cb(err, url)\n *\n * @jsonWire GET /session/:sessionId/url\n */\ncommands.url = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/url'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * allCookies() -> cb(err, cookies)\n *\n * @jsonWire GET /session/:sessionId/cookie\n */\ncommands.allCookies = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/cookie'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * setCookie(cookie, cb) -> cb(err)\n * cookie example:\n *  {name:'fruit', value:'apple'}\n * Optional cookie fields:\n *  path, domain, secure, expiry\n *\n * @jsonWire POST /session/:sessionId/cookie\n */\ncommands.setCookie = function(cookie) {\n  var cb = findCallback(arguments);\n  // setting secure otherwise selenium server throws\n  if(cookie){ cookie.secure = cookie.secure || false; }\n\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/cookie'\n    , data: { cookie: cookie }\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * deleteAllCookies(cb) -> cb(err)\n *\n * @jsonWire DELETE /session/:sessionId/cookie\n */\ncommands.deleteAllCookies = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'DELETE'\n    , relPath: '/cookie'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * deleteCookie(name, cb) -> cb(err)\n *\n * @jsonWire DELETE /session/:sessionId/cookie/:name\n */\ncommands.deleteCookie = function(name) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'DELETE'\n    , relPath: '/cookie/' + encodeURIComponent(name)\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * getOrientation(cb) -> cb(err, orientation)\n *\n * @jsonWire GET /session/:sessionId/orientation\n */\ncommands.getOrientation = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/orientation'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * setOrientation(cb) -> cb(err, orientation)\n *\n * @jsonWire POST /session/:sessionId/orientation\n */\ncommands.setOrientation = function(orientation) {\n  orientation = orientation.toUpperCase();\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/orientation'\n    , data: { orientation: orientation }\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * setLocalStorageKey(key, value, cb) -> cb(err)\n *\n * # uses safeExecute() due to localStorage bug in Selenium\n *\n * @jsonWire POST /session/:sessionId/local_storage\n */\ncommands.setLocalStorageKey = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      key = fargs.all[0],\n      value = fargs.all[1];\n\n  commands.safeExecute.apply(\n    this,\n    [\"localStorage.setItem(arguments[0], arguments[1])\", [key, value], cb]\n  );\n};\n\n/**\n * getLocalStorageKey(key, cb) -> cb(err)\n *\n * # uses safeEval() due to localStorage bug in Selenium\n *\n * @jsonWire GET /session/:sessionId/local_storage/key/:key\n */\ncommands.getLocalStorageKey = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      key = fargs.all[0];\n\n  commands.safeEval.apply(\n    this,\n    [\"localStorage.getItem('\" + key + \"')\", cb]\n  );\n};\n\n/**\n * removeLocalStorageKey(key, cb) -> cb(err)\n *\n * # uses safeExecute() due to localStorage bug in Selenium\n *\n * @jsonWire DELETE /session/:sessionId/local_storage/key/:key\n */\ncommands.removeLocalStorageKey = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      key = fargs.all[0];\n\n  commands.safeExecute.apply(\n    this,\n    [\"localStorage.removeItem(arguments[0])\", [key], cb]\n  );\n};\n\n/**\n * clearLocalStorage(cb) -> cb(err)\n *\n * # uses safeExecute() due to localStorage bug in Selenium\n *\n * @jsonWire DELETE /session/:sessionId/local_storage\n */\ncommands.clearLocalStorage = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n\n  commands.safeExecute.apply(\n    this,\n    [\"localStorage.clear()\", cb]\n  );\n};\n\n// deprecated\nvar _isVisible1 = function(element){\n  var cb = findCallback(arguments);\n  commands.getComputedCSS.apply(this, [element, \"display\", function(err, display){\n    if(err){\n      return cb(err);\n    }\n\n    cb(null, display !== \"none\");\n  }]);\n};\n\n// deprecated\nvar _isVisible2 = function(queryType, querySelector){\n  var cb = findCallback(arguments);\n  commands.elementIfExists.apply(this, [queryType, querySelector, function(err, element){\n    if(err){\n      return cb(err);\n    }\n\n    if(element){\n      element.isVisible(cb);\n    } else {\n      cb(null, false); }\n  }]);\n};\n\n// deprecated\ncommands.isVisible = function() {\n  deprecator.warn('isVisible', 'isVisible has been deprecated, use isDisplayed instead.');\n\n  var args = __slice.call(arguments, 0);\n  if (args.length <= 2) {\n    _isVisible1.apply(this, args);\n  } else {\n    _isVisible2.apply(this, args);\n  }\n};\n\n/**\n * Retrieves the pageIndex element (added for Appium):\n * getPageIndex(element, cb) -> cb(err, pageIndex)\n */\ncommands.getPageIndex = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/pageIndex'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * getLocation(element, cb) -> cb(err, location)\n *\n * @jsonWire GET /session/:sessionId/element/:id/location\n */\ncommands.getLocation = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/location'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * getLocationInView(element, cb) -> cb(err, location)\n *\n * @jsonWire GET /session/:sessionId/element/:id/location_in_view\n */\ncommands.getLocationInView = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/location_in_view'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * getSize(element, cb) -> cb(err, size)\n *\n * @jsonWire GET /session/:sessionId/element/:id/size\n */\ncommands.getSize = function(element) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/element/' + element + '/size'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * Uploads a local file using undocumented\n * POST /session/:sessionId/file\n * uploadFile(filepath, cb) -> cb(err, filepath)\n */\ncommands.uploadFile = function(filepath) {\n  var cb = findCallback(arguments);\n  var _this = this;\n  var archiver = require('archiver');\n\n  var archive = archiver('zip');\n  var dataList = [];\n\n  archive\n  .on('error', function(err) {\n    cb(err);\n  })\n  .on('data', function(data) {\n    dataList.push(data);\n  })\n  .on('end', function() {\n    _this._jsonWireCall({\n    method: 'POST'\n      , relPath: '/file'\n      , data: { file: Buffer.concat(dataList).toString('base64') },\n      cb: callbackWithData(cb, _this)\n    });\n  });\n\n  archive\n  .append(\n    fs.createReadStream(filepath),\n    { name: path.basename(filepath) }\n  );\n\n  archive.finalize(function(err) {\n    if (err) {\n      cb(err);\n    }\n  });\n};\n\ncommands.waitForJsCondition = function(){\n  deprecator.warn('waitForJsCondition',\n    'waitForJsCondition has been deprecated, use waitFor + jsCondition asserter instead.');\n\n  var cb = findCallback(arguments);\n  var fargs = utils.varargs(arguments);\n  var jsConditionExpr = fargs.all[0],\n      timeout = fargs.all[1],\n      pollFreq = fargs.all[2];\n  commands.waitFor.apply(this, [\n    {\n      asserter: asserters.jsCondition(jsConditionExpr, true),\n      timeout: timeout,\n      pollFreq: pollFreq\n    }, function(err, value) {\n      if(err && err.message && err.message.match(/Condition/)) {\n        cb(new Error(\"Element condition wasn't satisfied!\"));\n      } else {\n        cb(err, value);\n      }\n    }]);\n};\ncommands.waitForCondition = commands.waitForJsCondition;\n\n/**\n * Waits for JavaScript condition to be true (async script polling within browser):\n * waitForConditionInBrowser(conditionExpr, timeout, pollFreq, cb) -> cb(err, boolean)\n * conditionExpr: condition expression, should return a boolean\n * timeout and  pollFreq are optional, default: 1000/100.\n * return true if condition satisfied, error otherwise.\n */\ncommands.waitForConditionInBrowser = function() {\n  var _this = this;\n  // parsing args\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      conditionExpr = fargs.all[0],\n      timeout = fargs.all[1] || 1000,\n      poll = fargs.all[2] || 100;\n\n  // calling script\n  commands.safeExecuteAsync.apply( _this, [_waitForConditionInBrowserJsScript,\n    [conditionExpr,timeout,poll], function(err,res) {\n      if(err) {return cb(err);}\n      if(res !== true) {return cb(\"waitForConditionInBrowser failure for: \" + conditionExpr);}\n      cb(null, res);\n    }\n  ]);\n};\n\n/**\n * sauceJobUpdate(jsonData, cb) -> cb(err)\n */\ncommands.sauceJobUpdate = function() {\n  var fargs = utils.varargs(arguments);\n  this._sauceJobUpdate.apply(this, fargs.array);\n};\n\n/**\n * sauceJobStatus(hasPassed, cb) -> cb(err)\n */\ncommands.sauceJobStatus = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      hasPassed = fargs.all[0];\n  this._sauceJobUpdate.apply(this, [{passed: hasPassed}, cb]);\n};\n\n/**\n * sleep(ms, cb) -> cb(err)\n */\ncommands.sleep = function(ms, cb) {\n  cb = cb || function() {};\n  setTimeout(cb , ms);\n};\n\n/**\n * noop(cb) -> cb(err)\n */\ncommands.noop = function(cb) {\n  if(cb) { cb(); }\n};\n\n/**\n * shakeDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/shake\n */\ncommands.shakeDevice = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/shake'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * shake(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/shake\n */\ncommands.shake = commands.shakeDevice;\n\n/**\n * lockDevice(seconds, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\ncommands.lockDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n           seconds = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/lock'\n    , data: {seconds: seconds}\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * lock(seconds, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\ncommands.lock = commands.lockDevice;\n\n/**\n * unlockDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\ncommands.unlockDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/unlock'\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * unlock(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/lock\n */\ncommands.unlock = commands.unlockDevice;\n\n/**\n * isLocked(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/is_locked\n */\ncommands.isLocked = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/is_locked'\n    , cb: callbackWithData(cb)\n  });\n};\n\n/**\n * deviceKeyEvent(keycode, metastate, cb) -> cb(err)\n * metastate is optional\n *\n * @jsonWire POST /session/:sessionId/appium/device/keyevent\n */\ncommands.deviceKeyEvent = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      keycode = fargs.all[0],\n      metastate = fargs.all[1];\n  var data = {keycode: keycode};\n  if(metastate) { data.metastate = metastate; }\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/keyevent'\n    , data: data\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * pressDeviceKey(keycode, metastate, cb) -> cb(err)\n * metastate is optional\n *\n * @jsonWire POST /session/:sessionId/appium/device/keyevent\n */\ncommands.pressDeviceKey = commands.deviceKeyEvent;\n\n/**\n * rotateDevice(element, opts, cb) -> cb(err)\n * rotateDevice(opts, cb) -> cb(err)\n * opts is like the following:\n * {x: 114, y: 198, duration: 5, radius: 3, rotation: 220, touchCount: 2}\n *\n * @jsonWire POST /session/:sessionId/appium/device/rotate\n */\ncommands.rotateDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      element = fargs.all[0],\n      opts = fargs.all[1];\n  if(!(element && element.value)) {\n    opts = element;\n    element = null;\n  }\n  var data = _.clone(opts);\n  if(element) { data.element = element.value.toString(); }\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/rotate'\n    , data: data\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * rotate(element, opts, cb) -> cb(err)\n * rotate(opts, cb) -> cb(err)\n * opts is like the following:\n * {x: 114, y: 198, duration: 5, radius: 3, rotation: 220, touchCount: 2}\n *\n * @jsonWire POST /session/:sessionId/appium/device/rotate\n */\ncommands.rotate = commands.rotateDevice;\n\n/**\n * getCurrentDeviceActivity(cb) -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/appium/device/current_activity\n */\ncommands.getCurrentDeviceActivity = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/appium/device/current_activity'\n    , cb: callbackWithData(cb, this)\n  });\n};\n/**\n * getCurrentActivity(cb) -> cb(err)\n *\n * @jsonWire GET /session/:sessionId/appium/device/current_activity\n */\ncommands.getCurrentActivity = commands.getCurrentDeviceActivity;\n\n/**\n * installAppOnDevice(appPath, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/install_app\n */\ncommands.installAppOnDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      appPath = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/install_app'\n    , data: { appPath: appPath}\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * installApp(appPath, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/install_app\n */\ncommands.installApp = commands.installAppOnDevice;\n\n/**\n * removeAppFromDevice(appId, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/remove_app\n */\ncommands.removeAppFromDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      appId = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/remove_app'\n    , data: { appId: appId}\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * removeApp(appId, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/remove_app\n */\ncommands.removeApp = commands.removeAppFromDevice;\n\n/**\n * isAppInstalledOnDevice(bundleId, cb) -> cb(isInstalled, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/app_installed\n */\ncommands.isAppInstalledOnDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      bundleId = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/app_installed'\n    , data: {bundleId: bundleId}\n    , cb: callbackWithData(cb, this)\n  });\n};\n/**\n * isAppInstalled(bundleId, cb) -> cb(isInstalled, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/app_installed\n */\ncommands.isAppInstalled = commands.isAppInstalledOnDevice;\n\n/**\n * hideKeyboard() -> cb(err)\n * hideKeyboard(keyName, cb) -> cb(err)\n * hideKeyboard({strategy: 'pressKey', key:'<key>'}) -> cb(err)\n * hideKeyboard({strategy: 'tapOutside'}) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/hide_keyboard\n */\ncommands.hideDeviceKeyboard = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  var data = {};\n  switch(typeof fargs.all[0]) {\n    case 'string':\n      data = {keyName: fargs.all[0]};\n      break;\n    case 'object':\n      data = fargs.all[0];\n      break;\n    default:\n      data= null;\n  }\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/hide_keyboard'\n    , data: data\n    , cb: simpleCallback(cb)\n  });\n};\ncommands.hideKeyboard = commands.hideDeviceKeyboard;\n\n/**\n * pushFileToDevice(pathOnDevice, base64Data, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/push_file\n */\ncommands.pushFileToDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      pathOnDevice = fargs.all[0],\n      base64Data = fargs.all[1];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/push_file'\n    , data: {path: pathOnDevice, data: base64Data}\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * pushFile(pathOnDevice, base64Data, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/push_file\n */\ncommands.pushFile = commands.pushFileToDevice;\n\n\n/**\n * pullFileFromDevice(pathOnDevice, cb) -> cb(base64EncodedData, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/pull_file\n */\ncommands.pullFileFromDevice = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      pathOnDevice = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/pull_file'\n    , data: {path: pathOnDevice}\n    , cb: callbackWithData(cb, this)\n  });\n};\n/**\n * pullFile(pathOnDevice, cb) -> cb(base64EncodedData, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/pull_file\n */\ncommands.pullFile = commands.pullFileFromDevice;\n\n/**\n * pullFolderFromDevice(pathOnDevice, cb) -> cb(base64EncodedData, err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/pull_folder\n */\n commands.pullFolderFromDevice = function() {\n   var fargs = utils.varargs(arguments);\n   var cb = fargs.callback,\n       pathOnDevice = fargs.all[0];\n   this._jsonWireCall({\n     method: 'POST'\n     , relPath: '/appium/device/pull_folder'\n     , data: {path: pathOnDevice}\n     , cb: callbackWithData(cb, this)\n   });\n };\n\n /**\n  * pullFolder(pathOnDevice, cb) -> cb(base64EncodedData, err)\n  *\n  * @jsonWire POST /session/:sessionId/appium/device/pull_folder\n  */\ncommands.pullFolder = commands.pullFolderFromDevice;\n\n/**\n * toggleAirplaneModeOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_airplane_mode\n */\ncommands.toggleAirplaneModeOnDevice = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/toggle_airplane_mode'\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleAirplaneMode(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_airplane_mode\n */\ncommands.toggleAirplaneMode = commands.toggleAirplaneModeOnDevice;\n/**\n * toggleFlightMode(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_airplane_mode\n */\ncommands.toggleFlightMode = commands.toggleAirplaneModeOnDevice;\n\n/**\n * toggleWiFiOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_wifi\n */\ncommands.toggleWiFiOnDevice = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/toggle_wifi'\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleWiFi(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_wifi\n */\ncommands.toggleWiFi = commands.toggleWiFiOnDevice;\n\n/**\n * toggleLocationServicesOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_location_services\n */\ncommands.toggleLocationServicesOnDevice = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/toggle_location_services'\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleLocationServices(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_location_services\n */\ncommands.toggleLocationServices = commands.toggleLocationServicesOnDevice;\n\n/**\n * toggleDataOnDevice(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_data\n */\ncommands.toggleDataOnDevice = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/toggle_data'\n    , cb: simpleCallback(cb)\n  });\n};\n/**\n * toggleData(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/toggle_data\n */\ncommands.toggleData = commands.toggleDataOnDevice;\n\n/**\n * launchApp(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/launch\n */\ncommands.launchApp = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/app/launch'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * closeApp(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/close\n */\ncommands.closeApp = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/app/close'\n    , cb: simpleCallback(cb)\n  });\n};\n\n\n/**\n * resetApp(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/reset\n */\ncommands.resetApp = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/app/reset'\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * backgroundApp(seconds, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/background\n */\ncommands.backgroundApp = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      seconds = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/app/background'\n    , data: {seconds: seconds}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * endTestCoverageForApp(intentToBroadcast, pathOnDevice) -> cb(base64Data,err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/end_test_coverage\n */\ncommands.endTestCoverageForApp = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      intent = fargs.all[0],\n      path = fargs.all[1];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/app/end_test_coverage'\n    , data: {intent: intent, path: path}\n    , cb: callbackWithData(cb, this)\n  });\n};\n/**\n * endTestCoverage(intentToBroadcast, pathOnDevice) -> cb(base64Data,err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/end_test_coverage\n */\ncommands.endTestCoverage = commands.endTestCoverageForApp;\n/**\n * endCoverage(intentToBroadcast, pathOnDevice) -> cb(base64Data,err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/end_test_coverage\n */\ncommands.endCoverage = commands.endTestCoverageForApp;\n\n/**\n * complexFindInApp(selector) -> cb(element(s))\n * Return a single element or an elements array depending on\n * selector\n *\n * @jsonWire POST /session/:sessionId/appium/app/complex_find\n */\ncommands.complexFindInApp = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      selector = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/app/complex_find'\n    , data: {selector: selector}\n    , cb: elementOrElementsCallback(cb, this)\n  });\n};\n\n/**\n * complexFind(selector) -> cb(element(s))\n * Return a single element or an elements array depending on\n * selector\n *\n * @jsonWire POST /session/:sessionId/appium/app/complex_find\n */\ncommands.complexFind = commands.complexFindInApp;\n\n/**\n * getAppStrings(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/app/strings\n */\ncommands.getAppStrings = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      language = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/app/strings'\n    , data: {language: language}\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * setImmediateValueInApp(element, value, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/element/:elementId?/value\n */\ncommands.setImmediateValueInApp = function(element, value) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/element/' + element.value.toString() + '/value'\n    , data: {value: value}\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * startActivity(options, cb) -> cb(err)\n * Start an arbitrary Android activity during a session. The 'options' parameter should\n * implement the interface {appPackage, appActivity, [appWaitPackage], [appWaitActivity]}.\n *\n * @jsonWire POST /session/:sessionId/appium/device/start_activity\n */\ncommands.startActivity = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n    options = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/start_activity'\n    , data: options\n    , cb: simpleCallback(cb)\n  });\n};\n\n/**\n * setImmediateValue(element, value, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/element/:elementId?/value\n */\ncommands.setImmediateValue = commands.setImmediateValueInApp;\n\n/**\n * setNetworkConnection(type, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/network_connection\n */\ncommands.setNetworkConnection = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/network_connection'\n    , data: {parameters: {type: fargs.all[0]}}\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * getNetworkConnection(cb) -> cb(err, networkConnectionInfo)\n *\n * @jsonWire GET /session/:sessionId/network_connection\n */\ncommands.getNetworkConnection = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/network_connection'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * openNotifications(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/device/open_notifications\n */\ncommands.openNotifications = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/device/open_notifications'\n    , cb: simpleCallback(cb, this)\n  });\n};\n\n/**\n * settings(cb) -> cb(err, settingsObject)\n *\n * @jsonWire GET /session/:sessionId/appium/settings\n */\ncommands.settings = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/appium/settings'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * updateSettings(settingsObject, cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/appium/settings\n */\ncommands.updateSettings = function() {\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/settings'\n    , data: {settings: fargs.all[0]}\n    , cb: simpleCallback(cb, this)\n  });\n};\n\n/**\n * availableIMEEngines(cb) -> cb(err, engines)\n *\n * @jsonWire GET /session/:sessionId/ime/available_engines\n */\ncommands.availableIMEEngines = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/ime/available_engines'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * activateIMEEngine(cb, engine) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/ime/activate\n */\ncommands.activateIMEEngine = function(engine) {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/ime/activate'\n    , data: { engine: engine }\n    , cb: simpleCallback(cb, this)\n  });\n};\n\n/**\n * deactivateIMEEngine(cb) -> cb(err)\n *\n * @jsonWire POST /session/:sessionId/ime/deactivate\n */\ncommands.deactivateIMEEngine = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/ime/deactivate'\n    , cb: simpleCallback(cb, this)\n  });\n};\n\n/**\n * activatedIMEEngine(cb) -> cb(err, active)\n *\n * @jsonWire GET /session/:sessionId/ime/activated\n */\ncommands.isIMEActive = function() {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/ime/activated'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * activeIMEEngine(cb) -> cb(err, activeEngine)\n *\n * @jsonWire GET /session/:sessionId/ime/active_engine\n */\ncommands.activeIMEEngine = function () {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/ime/active_engine'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * getDeviceTime(cb) -> cb(err, deviceTime)\n *\n * @jsonWire GET /session/:sessionId/appium/device/system_time\n */\ncommands.getDeviceTime = function () {\n  var cb = findCallback(arguments);\n  this._jsonWireCall({\n    method: 'GET'\n    , relPath: '/appium/device/system_time'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\n/**\n * touchId(cb) -> cb(err, touchId)\n * \n * @jsonWire POST /session/:sessionId/appium/simulator/touch_id\n */\ncommands.touchId = function(){\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback,\n      match = fargs.all[0];\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/simulator/touch_id'\n    , cb: callbackWithData(cb, this)\n    , data: {match: match}\n  });\n};\n\n/**\n * touchId(cb) -> cb(err, touchId)\n * \n * @jsonWire POST /session/:sessionId/appium/simulator/touch_id\n */\ncommands.toggleTouchIdEnrollment = function(){\n  var fargs = utils.varargs(arguments);\n  var cb = fargs.callback;\n  this._jsonWireCall({\n    method: 'POST'\n    , relPath: '/appium/simulator/toggle_touch_id_enrollment'\n    , cb: callbackWithData(cb, this)\n  });\n};\n\nmodule.exports = commands;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/tmp.js":"// inspired by https://github.com/raszi/node-tmp, but only\n// provides tmp paths.\n\nvar\n  fs     = require('fs'),\n  path   = require('path'),\n  os     = require('os'),\n  utils     = require('./utils');\n\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\nfunction _parseArguments() {\n  var fargs = utils.varargs(arguments);\n  var callback = fargs.callback;\n  var options = fargs.all[0];\n  return [ options, callback ];\n}\n\n/**\n * Gets the temp directory.\n *\n * @return {String}\n * @api private\n */\nfunction _getTMPDir() {\n  var tmpNames = [ 'TMPDIR', 'TMP', 'TEMP' ];\n\n  for (var i = 0, length = tmpNames.length; i < length; i++) {\n    if (_isUndefined(process.env[tmpNames[i]])) { continue; }\n\n    return process.env[tmpNames[i]];\n  }\n\n  // fallback to the default\n  return '/tmp';\n}\n\nvar\n  exists = fs.exists || path.exists,\n  tmpDir = os.tmpdir || os.tmpDir || _getTMPDir,\n  _TMP = tmpDir(),\n  randomChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\",\n  randomCharsLength = randomChars.length;\n\n/**\n * Gets a temporary file name.\n *\n * @param {Object} opts\n * @param {Function} cb\n * @api private\n */\nfunction _getTmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    template = opts.template,\n    templateDefined = !_isUndefined(template),\n    tries = opts.tries || 3;\n\n  if (isNaN(tries) || tries < 0)\n    { return cb(new Error('Invalid tries')); }\n\n  if (templateDefined && !template.match(/XXXXXX/))\n    { return cb(new Error('Invalid template provided')); }\n\n  function _getName() {\n\n    // prefix and postfix\n    if (!templateDefined) {\n      var name = [\n        (_isUndefined(opts.prefix)) ? 'tmp-' : opts.prefix,\n        process.pid,\n        (Math.random() * 0x1000000000).toString(36),\n        opts.postfix\n      ].join('');\n\n      return path.join(opts.dir || _TMP, name);\n    }\n\n    // mkstemps like template\n    var chars = [];\n\n    for (var i = 0; i < 6; i++) {\n      chars.push(randomChars.substr(Math.floor(Math.random() * randomCharsLength), 1));\n    }\n\n    return template.replace(/XXXXXX/, chars.join(''));\n  }\n\n  (function _getUniqueName() {\n    var name = _getName();\n\n    // check whether the path exists then retry if needed\n    exists(name, function _pathExists(pathExists) {\n      if (pathExists) {\n        if (tries-- > 0) { return _getUniqueName(); }\n\n        return cb(new Error('Could not get a unique tmp filename, max tries reached'));\n      }\n\n      cb(null, name);\n    });\n  }());\n}\n\n// exporting all the needed methods\nmodule.exports.tmpdir = _TMP;\nmodule.exports.tmpName = _getTmpName;\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/asserters.js":"var _ = require('./lodash');\nvar __slice = Array.prototype.slice;\nvar utils = require(\"./utils\");\nvar deprecator = utils.deprecator;\n\nfunction Asserter(_assert){\n  this.assert = _assert;\n}\n\n/**\n * asserters.nonEmptyText\n *\n * @asserter\n */\nvar nonEmptyText = new Asserter(\n  function (target, cb) {\n    target.text(function(err, text) {\n      if(err) { return cb(err); }\n      var satisfied = text && _(text).trim().value().length >0;\n      cb(null, satisfied, satisfied? text : undefined);\n    });\n  }\n);\n\n/**\n * asserters.textInclude(content) -> Asserter\n *\n * @asserter\n */\nfunction textInclude(content) {\n  return new Asserter(\n    function(target, cb) {\n      target.text(function(err, text) {\n        if(err) { return cb(err); }\n        var satisfied = text && _(text).includeString(content).value();\n        cb(null, satisfied, satisfied? text : undefined);\n      });\n    }\n  );\n}\n\n/**\n * asserters.isVisible\n *\n * @asserter\n */\nvar isDisplayed = new Asserter(\n  function(el,cb) {\n    el.isDisplayed(function(err, displayed) {\n      if(err) { return cb(err); }\n      cb(null, displayed);\n    });\n  }\n);\nvar isVisible = new Asserter(\n  function() {\n    deprecator.warn('isVisible asserter', 'isVisible asserter has been deprecated, use isDisplayed asserter instead.');\n    var args = __slice.call(arguments, 0);\n    isDisplayed.assert.apply(this, args);\n  }\n);\n\n/**\n * asserters.isHidden\n *\n * @asserter\n */\nvar isNotDisplayed = new Asserter(\n  function(el,cb) {\n    el.isDisplayed(function(err, displayed) {\n      if(err) { return cb(err); }\n      cb(null, !displayed);\n    });\n  }\n);\nvar isHidden = new Asserter(\n  function() {\n    deprecator.warn('isHidden asserter', 'isHidden asserter has been deprecated, use isNotDisplayed asserter instead.');\n    var args = __slice.call(arguments, 0);\n    isNotDisplayed.assert.apply(this, args);\n  }\n);\n\n/**\n * asserters.jsCondition(jsConditionExpr) -> Asserter\n * jsConditionExpr: js script expression, should evaluate as boolean.\n *\n * @asserter\n */\nfunction jsCondition(jsConditionExpr, safe) {\n  // jshint evil: true\n  if(safe === undefined) { safe = false; }\n  return new Asserter(\n    function(browser, cb) {\n      var _eval = safe? browser.safeEval : browser.eval;\n      _eval.apply( browser , [jsConditionExpr, function(err, res) {\n        if(err) {return cb(err);}\n        cb(null, res, res);\n      }]);\n    }\n  );\n}\n\nmodule.exports = {\n  Asserter: Asserter,\n  nonEmptyText: nonEmptyText,\n  isDisplayed: isDisplayed,\n  isNotDisplayed: isNotDisplayed,\n  textInclude: textInclude,\n  jsCondition: jsCondition,\n  // deprecated\n  isVisible: isVisible,\n  isHidden: isHidden,\n};\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/build/safe-execute.js":"module.exports = \"/* jshint evil:true */var args = Array.prototype.slice.call(arguments, 0);var code = args[0], fargs = args[1];var wrap = function() {  return eval(code);};return wrap.apply(this, fargs);\"","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/build/safe-execute-async.js":"module.exports = \"/* jshint evil:true */var args = Array.prototype.slice.call(arguments, 0);var code = args[0], fargs = args[1], done = args[2];var wrap = function() {  return eval(code);};fargs.push(done);wrap.apply(this, fargs);\"","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/build/wait-for-cond-in-browser.js":"module.exports = \"/* jshint evil:true */var args = Array.prototype.slice.call(arguments, 0);var condExpr = args[0], timeout = args[1],    poll = args[2], cb = args[3];var waitForConditionImpl = function(conditionExpr, limit, poll, cb) {  var res;  if ((new Date().getTime()) < limit) {    res = eval(conditionExpr);    if (res === true ) {      cb(res);    } else {      setTimeout(function() {        waitForConditionImpl(conditionExpr, limit, poll, cb);      }, poll);    }  } else {    res = eval(conditionExpr);    return cb(res);  }};var limit = (new Date().getTime()) + timeout;waitForConditionImpl(condExpr, limit, poll, cb);\"","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/actions.js":"var _ = require('lodash'),\n    __slice = Array.prototype.slice,\n    _ = require('lodash'),\n    Webdriver = require('./webdriver'),\n    Element = require('./element');\n\n/**\n * new wd.TouchAction()\n * TouchAction constructor\n *\n * @actions\n */\nvar TouchAction = function (driver) {\n  this.driver = driver;\n  this.gestures = [];\n};\n\nTouchAction.prototype.addGesture = function(action, opts) {\n  opts = opts || {};\n  var el = opts.element || opts.el;\n  if(el && !(el instanceof Element)) {\n    throw new Error('Invalid element or el field passed');\n  }\n\n  // preparing opts\n  var finalOpts = {};\n  _(opts).each(function(value, name) {\n    if(_.isNumber(value)) {\n      finalOpts[name] = value;\n    } else if(value instanceof Element) {\n      finalOpts[name] = value.value;\n    } else if(value) {\n      finalOpts[name] = value;\n    }\n  });\n  if(finalOpts.el) {\n    finalOpts.element = finalOpts.el;\n    delete finalOpts.el;\n  }\n\n  // adding action\n  this.gestures.push({\n    action: action,\n    options: finalOpts\n  });\n};\n\nTouchAction.prototype.toJSON = function() {\n  return this.gestures;\n};\n\n/**\n * touchAction.longPress({el, x, y})\n * pass el or (x,y) or both\n *\n * @actions\n */\nTouchAction.prototype.longPress = function (opts) {\n  this.addGesture('longPress', opts);\n  return this;\n};\n\n/**\n * touchAction.moveTo({el, x, y})\n * pass el or (x,y) or both\n *\n * @actions\n */\nTouchAction.prototype.moveTo = function (opts) {\n  this.addGesture('moveTo', opts);\n  return this;\n};\n\n/**\n * touchAction.press({el, x, y})\n * pass el or (x,y) or both\n *\n * @actions\n */\nTouchAction.prototype.press = function (opts) {\n  this.addGesture('press', opts);\n  return this;\n};\n\n/**\n * touchAction.release()\n *\n * @actions\n */\nTouchAction.prototype.release = function () {\n  this.addGesture('release', {});\n  return this;\n};\n\n/**\n * touchAction.tap({el, x, y, count})\n * pass el or (x,y) or both\n * count is optional\n *\n * @actions\n */\nTouchAction.prototype.tap = function (opts) {\n  this.addGesture('tap', opts);\n  return this;\n};\n\n/**\n * touchAction.wait({ms})\n * touchAction.wait(ms)\n * ms is optional\n *\n * @actions\n */\nTouchAction.prototype.wait = function (opts) {\n  if(_.isNumber(opts)) { opts = {ms: opts}; }\n  this.addGesture('wait', opts);\n  return this;\n};\n\n/**\n * cancel the action\n *\n * @actions\n */\nTouchAction.prototype.cancel = function () {\n  this.gestures = [];\n};\n\n/**\n * perform the action\n *\n * @actions\n */\nTouchAction.prototype.perform = function(cb) {\n  if(typeof cb === 'function') {\n    this.driver.performTouchAction(this, cb);\n  } else {\n    return this.driver.performTouchAction(this);\n  }\n};\n\n/**\n * new wd.MultiAction()\n * MultiAction constructor\n *\n * @actions\n */\nvar MultiAction = function (browserOrElement) {\n  if(browserOrElement instanceof Element) {\n    this.element = browserOrElement;\n    this.browser = this.element.browser;\n  } else if (browserOrElement instanceof Webdriver) {\n    this.browser = browserOrElement;\n  }\n  this.actions = [];\n};\n\nMultiAction.prototype.toJSON = function() {\n  var output = {};\n  if(this.element) { output.elementId = this.element.value; }\n  output.actions = _(this.actions).map(function(action) {\n    return action.toJSON();\n  }).value();\n  return output;\n};\n\n/**\n * multiAction.add(touchAction)\n *\n * @actions\n */\nMultiAction.prototype.add = function () {\n  var actions = __slice.call(arguments, 0);\n  this.actions = this.actions.concat(actions);\n  return this;\n};\n\n/**\n * multiAction.cancel()\n *\n * @actions\n */\nMultiAction.prototype.cancel = function() {\n  this.actions = [];\n};\n\n/**\n * multiAction.perform()\n *\n * @actions\n */\nMultiAction.prototype.perform = function(cb) {\n  if(typeof cb === 'function') {\n    if(this.element){\n      this.element.performMultiAction(this, cb);\n    } else {\n      this.browser.performMultiAction(this, cb);\n    }\n  } else {\n    if(this.element){\n      return this.element.performMultiAction(this);\n    } else {\n      return this.browser.performMultiAction(this);\n    }\n  }\n};\n\nmodule.exports = {\n  TouchAction: TouchAction,\n  MultiAction: MultiAction\n};\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/promise-webdriver.js":"var __slice = Array.prototype.slice,\n    Q = require('q'),\n    _ = require('./lodash'),\n    EventEmitter = require('events').EventEmitter,\n    slice = Array.prototype.slice.call.bind(Array.prototype.slice),\n    utils = require('./utils');\n\n// The method below returns no result, so we are able hijack the result to\n// preserve the element scope.\n// This alows for thing like: field.click().clear().input('hello').getValue()\nvar elementChainableMethods = ['clear','click','doubleClick','doubleclick',\n  'flick','tap','sendKeys','submit','type','keys','moveTo','sleep','noop'];\n\n// gets the list of methods to be promisified.\nfunction filterPromisedMethods(Obj) {\n  return _(Obj).functionsIn().filter(function(fname) {\n    return  !fname.match('^newElement$|^toJSON$|^toString$|^_') &&\n            !EventEmitter.prototype[fname];\n  }).value();\n}\n\nmodule.exports = function(WebDriver, Element, chainable) {\n\n  // wraps element + browser call in an enriched promise.\n  // This is the same as in the first promise version, but enrichment +\n  // event logging were added.\n  function wrap(fn, fname) {\n    return function() {\n      var _this = this;\n      var callback;\n      var args = slice(arguments);\n      var deferred = Q.defer();\n      deferred.promise.then(function() {\n        _this.emit(\"promise\", _this, fname , args , \"finished\");\n      });\n\n\n      // Remove any undefined values from the end of the arguments array\n      // as these interfere with our callback detection below\n      for (var i = args.length - 1; i >= 0 && args[i] === undefined; i--) {\n        args.pop();\n      }\n\n      // If the last argument is a function assume that it's a callback\n      // (Based on the API as of 2012/12/1 this assumption is always correct)\n      if(typeof args[args.length - 1] === 'function')\n      {\n        // Remove to replace it with our callback and then call it\n        // appropriately when the promise is resolved or rejected\n        callback = args.pop();\n        deferred.promise.then(function(value) {\n          callback(null, value);\n        }, function(error) {\n          callback(error);\n        });\n      }\n\n      args.push(deferred.makeNodeResolver());\n      _this.emit(\"promise\", _this, fname , args , \"calling\");\n      fn.apply(this, args);\n\n      if(chainable) {\n        return this._enrich(deferred.promise);\n      } else {\n        return deferred.promise;\n      }\n    };\n  }\n\n  // Element replacement.\n  var PromiseElement = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return Element.apply(this, args);\n  };\n  PromiseElement.prototype = Object.create(Element.prototype);\n  PromiseElement.prototype.isPromised = true;\n\n  // WebDriver replacement.\n  var PromiseWebdriver = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return WebDriver.apply(this, args);\n  };\n  PromiseWebdriver.prototype = Object.create(WebDriver.prototype);\n  PromiseWebdriver.prototype.isPromised = true;\n  PromiseWebdriver.prototype.defaultChainingScope = 'browser';\n\n  PromiseWebdriver.prototype.getDefaultChainingScope = function() {\n    return this.defaultChainingScope;\n  };\n\n\n  // wrapping browser methods with promises.\n  _(filterPromisedMethods(WebDriver.prototype)).each(function(fname) {\n    PromiseWebdriver.prototype[fname] = wrap(WebDriver.prototype[fname], fname);\n  });\n\n  // wrapping element methods with promises.\n  _(filterPromisedMethods(Element.prototype)).each(function(fname) {\n    PromiseElement.prototype[fname] = wrap(Element.prototype[fname], fname);\n  });\n\n  PromiseWebdriver.prototype.newElement = function(jsonWireElement) {\n    return new PromiseElement(jsonWireElement, this);\n  };\n\n  // enriches a promise with the browser + element methods.\n  PromiseWebdriver.prototype._enrich = function(obj, currentEl) {\n    var _this = this;\n    // There are cases were enrich may be called on non-promise objects.\n    // It is easier and safer to check within the method.\n    if(utils.isPromise(obj) && !obj.__wd_promise_enriched) {\n\n      var promise = obj;\n\n      // __wd_promise_enriched is there to avoid enriching twice.\n      promise.__wd_promise_enriched = true;\n\n\n      // making sure all the sub-promises are also enriched.\n\n      _(promise).functionsIn()\n        // promiseDispatch is used a lot, and we know it doesn't need to be enriched\n        .filter(function(fname) { return fname !== 'promiseDispatch'; })\n        .each(function(fname) {\n          var _orig = promise[fname];\n          promise[fname] = function() {\n            var subobj = _orig.apply(this, __slice.call(arguments, 0));\n\n            return this._enrich(\n              subobj, currentEl);\n          };\n        });\n\n      // we get the list of methods dynamically.\n      var promisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this));\n      _this.sampleElement = _this.sampleElement || _this.newElement(1);\n      var elementPromisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this.sampleElement));\n      var allPromisedMethods = _.union(promisedMethods, elementPromisedMethods);\n\n      // adding browser + element methods to the current promise.\n      _(allPromisedMethods).each(function(fname) {\n        promise[fname] = function() {\n          var args = __slice.call(arguments, 0);\n          // This is a hint to figure out if we need to call a browser method or\n          // an element method.\n          // \"<\" --> browser method\n          // \">\" --> element method\n          var scopeHint;\n          if(args && args[0] && typeof args[0] === 'string' && args[0].match(/^[<>]$/)) {\n            scopeHint = args[0];\n            args = _.drop(args);\n          }\n\n          return this.then(function(res) {\n            var el;\n            // if the result is an element it has priority\n            if(Element && res instanceof Element) {\n              el = res; }\n            // if we are within an element\n            el = el || currentEl;\n\n            // testing the water for the next call scope\n            var isBrowserMethod =\n              _.indexOf(promisedMethods, fname) >= 0;\n            var isElementMethod =\n              el && _.indexOf(elementPromisedMethods, fname) >= 0;\n            if(!isBrowserMethod && !isElementMethod) {\n              // doesn't look good\n              throw new Error(\"Invalid method \" + fname);\n            }\n\n            if(isBrowserMethod && isElementMethod) {\n              // we need to resolve the conflict.\n              if(scopeHint === '<') {\n                isElementMethod = false;\n              } else if(scopeHint === '>') {\n                isBrowserMethod = false;\n              } else if(fname.match(/element/) || (Element && args[0] instanceof Element)) {\n                // method with element locators are browser scoped by default.\n                if(_this.defaultChainingScope === 'element') { isBrowserMethod = false; }\n                else { isElementMethod = false; } // default\n              } else if(Element && args[0] instanceof Element) {\n                // When an element is passed, we are in the global scope.\n                isElementMethod = false;\n              } else {\n                // otherwise we stay in the element scope to allow sequential calls\n                isBrowserMethod = false;\n              }\n            }\n\n            if(isElementMethod) {\n              // element method case.\n              return el[fname].apply(el, args).then(function(res) {\n                if(_.indexOf(elementChainableMethods, fname) >= 0) {\n                  // method like click, where no result is expected, we return\n                  // the element to make it chainable\n                  return el;\n                } else {\n                  return res; // we have no choice but loosing the scope\n                }\n              });\n            }else{\n              // browser case.\n              return _this[fname].apply(_this, args);\n            }\n          });\n        };\n      });\n      // transfering _enrich\n      promise._enrich = function(target) {\n        return _this._enrich(target, currentEl);\n      };\n\n      // gets the element at index (starting at 0)\n      promise.at = function(i) {\n        return _this._enrich( promise.then(function(vals) {\n          return vals[i];\n        }), currentEl);\n      };\n\n      // gets the element at index (starting at 0)\n      promise.last = function() {\n        return promise.then(function(vals) {\n          return vals[vals.length - 1];\n        });\n      };\n\n      // gets nth element (starting at 1)\n      promise.nth = function(i) {\n        return promise.at(i - 1);\n      };\n\n      // gets the first element\n      promise.first = function() {\n        return promise.nth(1);\n      };\n\n      // gets the first element\n      promise.second = function() {\n        return promise.nth(2);\n      };\n\n      // gets the first element\n      promise.third = function() {\n        return promise.nth(3);\n      };\n\n      // print error\n      promise.printError = function(prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich( promise.catch(function(err) {\n          console.log(prepend + err);\n          throw err;\n        }), currentEl);\n      };\n\n      // print\n      promise.print = function(prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich( promise.then(function(val) {\n          console.log(prepend + val);\n        }), currentEl);\n      };\n    }\n    return obj;\n  };\n\n  /**\n   * Starts the chain (promised driver only)\n   * browser.chain()\n   * element.chain()\n   */\n  PromiseWebdriver.prototype.chain = PromiseWebdriver.prototype.noop;\n  PromiseElement.prototype.chain = PromiseElement.prototype.noop;\n\n  /**\n   * Resolves the promise (promised driver only)\n   * browser.resolve(promise)\n   * element.resolve(promise)\n   */\n  PromiseWebdriver.prototype.resolve = function(promise) {\n    var qPromise = new Q(promise);\n    this._enrich(qPromise);\n    return qPromise;\n  };\n  PromiseElement.prototype.resolve = function(promise) {\n    var qPromise = new Q(promise);\n    this._enrich(qPromise);\n    return qPromise;\n  };\n\n\n  // used to by chai-as-promised and custom methods\n  PromiseElement.prototype._enrich = function(target) {\n    if(chainable) { return this.browser._enrich(target, this); }\n  };\n\n  // used to wrap custom methods\n  PromiseWebdriver._wrapAsync = wrap;\n\n  // helper to allow easier promise debugging.\n  PromiseWebdriver.prototype._debugPromise = function() {\n    this.on('promise', function(context, method, args, status) {\n      args = _.clone(args);\n      if(context instanceof PromiseWebdriver) {\n        context = '';\n      } else {\n        context = ' [element ' + context.value + ']';\n      }\n      if(typeof _.last(args) === 'function') {\n        args.pop();\n      }\n      args = ' ( ' + _(args).map(function(arg) {\n        if(arg instanceof Element) {\n          return arg.toString();\n        } else if(typeof arg === 'object') {\n          return JSON.stringify(arg);\n        } else {\n          return arg;\n        }\n      }).join(', ') + ' )';\n      console.log(' --> ' + status + context + \" \" + method + args);\n    });\n  };\n\n  return {\n    PromiseWebdriver: PromiseWebdriver,\n    PromiseElement: PromiseElement\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/browser-scripts/safe-execute-async.js":"/* jshint evil:true */\nvar args = Array.prototype.slice.call(arguments, 0);\nvar code = args[0], fargs = args[1], done = args[2];\nvar wrap = function() {\n  return eval(code);\n};\nfargs.push(done);\nwrap.apply(this, fargs);\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/browser-scripts/safe-execute.js":"/* jshint evil:true */\nvar args = Array.prototype.slice.call(arguments, 0);\nvar code = args[0], fargs = args[1];\nvar wrap = function() {\n  return eval(code);\n};\nreturn wrap.apply(this, fargs);\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/browser-scripts/wait-for-cond-in-browser.js":"/* jshint evil:true */\nvar args = Array.prototype.slice.call(arguments, 0);\nvar condExpr = args[0], timeout = args[1],\n    poll = args[2], cb = args[3];\nvar waitForConditionImpl = function(conditionExpr, limit, poll, cb) {\n  var res;\n  if ((new Date().getTime()) < limit) {\n    res = eval(conditionExpr);\n    if (res === true ) {\n      cb(res);\n    } else {\n      setTimeout(function() {\n        waitForConditionImpl(conditionExpr, limit, poll, cb);\n      }, poll);\n    }\n  } else {\n    res = eval(conditionExpr);\n    return cb(res);\n  }\n};\nvar limit = (new Date().getTime()) + timeout;\nwaitForConditionImpl(condExpr, limit, poll, cb);\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/gulpfile.js":"var gulp = require('gulp'),\n    jshint = require('gulp-jshint'),\n    jshintStylish = require('jshint-stylish'),\n    Q = require('q'),\n    runSequence = Q.denodeify(require('run-sequence')),\n    path = require('path'),\n    _ = require('lodash'),\n    args   = require('yargs').argv,\n    urlLib = require('url'),\n    mochaStream = require('spawn-mocha-parallel').mochaStream,\n    httpProxy = require('http-proxy'),\n    sauceConnectLauncher = require('sauce-connect-launcher'),\n    async = require('async');\n\nrequire('./test/helpers/env');\n\nargs.browsers = (args.browser || 'chrome').split(',');\nargs.sauce = args.sauce ? true : false;\n\nvar BROWSERS = ['chrome', 'firefox'];\nif (args.sauce) { BROWSERS.push('explorer'); }\nvar MOBILE_BROWSERS = ['android', 'ios', 'iphone', 'ipad', 'android_phone'];\nprocess.env.SAUCE_CONNECT_VERSION = process.env.SAUCE_CONNECT_VERSION || '4.3';\nprocess.env.SAUCE_CONNECT_VERBOSE = false;\n\nvar PROXY_PORT = 5050;\nvar expressPort = 3000; // incremented after each test to avoid colision\n\nfunction buildMochaOpts(opts) {\n\n  var mochaOpts = {\n    flags: {\n      u: 'bdd-with-opts',\n      R: 'spec',\n      c: true\n    },\n    bin: path.join(__dirname,  'node_modules/.bin/mocha'),\n    concurrency: args.concurrency | process.env.CONCURRENCY || 3\n  };\n  if(args.grep) {\n    mochaOpts.flags.g = args.grep;\n  }\n  mochaOpts.env = function() {\n    var env = _.clone(process.env);\n    if(opts.unit) {\n      // unit test\n      delete env.SAUCE;\n      delete env.SAUCE_USERNAME;\n      delete env.SAUCE_ACCESS_KEY;\n    } else {\n      // midway + e2e tests\n      env.BROWSER = opts.browser;\n      env.SAUCE = args.sauce;\n    }\n    if(opts.midway) {\n      // local server port\n      env.EXPRESS_PORT = expressPort;\n      expressPort++;\n      if(env.SAUCE) {\n        env.MIDWAY_ROOT_URL = 'http://127.0.0.1:' + PROXY_PORT + '/' +\n          env.EXPRESS_PORT;\n      }\n      if(process.env.TRAVIS_JOB_NUMBER) {\n        env.TUNNEL_IDENTIFIER  = process.env.TRAVIS_JOB_NUMBER;\n      }\n    }\n    return env;\n  };\n  return mochaOpts;\n}\n\ngulp.task('lint', function() {\n//  return gulp.src(['lib/**/*.js','test/**/*.js','browser-scripts/**/*.js'])\n  return gulp.src(['lib/**/*.js'])\n    .pipe(jshint())\n    .pipe(jshint.reporter(jshintStylish))\n    .pipe(jshint.reporter('fail'));\n});\n\ngulp.task('test-unit', function () {\n  var opts = buildMochaOpts({ unit: true });\n  var mocha = mochaStream(opts);\n  return gulp.src('test/specs/**/*-specs.js', {read: false})\n    .pipe(mocha)\n    .on('error',  console.warn.bind(console));\n});\n\ngulp.task('test-midway-multi', function () {\n  var opts = buildMochaOpts({ midway: true, browser: 'multi' });\n  var mocha = mochaStream(opts);\n  return gulp.src('test/midway/multi/**/*-specs.js', {\n    read: false})\n    .pipe(mocha)\n    .on('error', console.warn.bind(console));\n});\n\n_(BROWSERS).each(function(browser) {\n  gulp.task('test-midway-' + browser, function () {\n    var opts = buildMochaOpts({ midway: true, browser: browser });\n    var mocha = mochaStream(opts);\n    return gulp.src([\n        'test/midway/**/*-specs.js',\n        '!test/midway/multi/**'\n      ], {read: false})\n      .pipe(mocha)\n      .on('error', console.warn.bind(console));\n  });\n  gulp.task('test-e2e-' + browser, function () {\n    var opts = buildMochaOpts({ browser: browser });\n    var mocha = mochaStream(opts);\n    return gulp.src('test/e2e/**/*-specs.js', {read: false})\n      .pipe(mocha)\n      .on('error', console.warn.bind(console));\n  });\n});\n\n_(MOBILE_BROWSERS).each(function(browser) {\n  gulp.task('test-midway-' + browser, function () {\n    var opts = buildMochaOpts({ midway: true, browser: browser });\n    var mocha = mochaStream(opts);\n    return gulp.src([\n      'test/midway/api-nav-specs.js',\n      'test/midway/api-el-specs.js',\n      'test/midway/api-exec-specs.js',\n      'test/midway/mobile-specs.js',\n    ], {read: false})\n    .pipe(mocha)\n    .on('error', console.warn.bind(console));\n  });\n});\n\ngulp.task('test-midway', function() {\n  var midwayTestTasks = [];\n  _(args.browsers).each(function(browser) {\n    midwayTestTasks.push('test-midway-' + browser);\n  });\n  return runSequence('pre-midway', midwayTestTasks)\n    .finally(function() {\n      return runSequence('post-midway');\n    });\n});\n\ngulp.task('test-e2e', function() {\n  var e2eTestTasks = [];\n  _(args.browsers).chain().without('multi').each(function(browser) {\n    e2eTestTasks.push('test-e2e-' + browser);\n  });\n  if(e2eTestTasks.length > 0){\n    return runSequence(e2eTestTasks);\n  }\n});\n\ngulp.task('test', function() {\n  var seq = ['lint', 'test-unit', 'test-midway-multi'];\n  _(BROWSERS).each(function(browser) {\n     seq.push('test-midway-' + browser);\n     seq.push('test-e2e-' + browser);\n  });\n  return runSequence.apply(null, seq);\n});\n\nvar server;\ngulp.task('start-proxy', function(done) {\n  var proxy = httpProxy.createProxyServer({});\n  var proxyQueue;\n  var throttle = args.throttle || process.env.THROTTLE;\n  if(throttle) {\n    proxyQueue = async.queue(function(task, done) {\n\n      proxy.web(task.req, task.res, { target: 'http://127.0.0.1:' + task.port });\n      task.res.on('finish', function() {\n        done();\n      });\n    }, parseInt(args.throttle, 10));\n  }\n  server = require('http').createServer(function(req, res) {\n    try {\n      if(req.url.match(/^\\/favicon/)) {\n        res.write(\"404 Not Found\\n\");\n        res.end();\n        return;\n      }\n      // extracting port from url and rewriting url\n      var url = urlLib.parse(req.url);\n      var re = /\\/(.*?)\\//;\n      var m = re.exec(url.pathname);\n      var port = parseInt(m[1]);\n      url.pathname = url.pathname.replace(re, '/');\n      req.url = url.format();\n      if(throttle) {\n        proxyQueue.push({req: req, res: res, port: port});\n      } else {\n        proxy.web(req, res, { target: 'http://127.0.0.1:' + port });\n      }\n    } catch (err) {\n      try{\n        console.error('Proxy error for: ', req.url + ':' , err);\n        res.writeHead(500, {\n          'Content-Type': 'text/plain'\n        });\n        res.end('Something went wrong.');\n      } catch (ign) {}\n    }\n  });\n\n  server.on('error', function(err) {\n    console.error('Proxy error: ', err);\n  });\n\n  console.log(\"listening on port\", PROXY_PORT);\n  server.listen(PROXY_PORT, done);\n});\n\ngulp.task('stop-proxy', function(done) {\n  // stop proxy, exit after 5 ec if hanging\n  done = _.once(done);\n  var t = setTimeout(function() {\n    done();\n  }, 5000);\n  if(server) {\n    server.close(function() {\n      clearTimeout(t);\n      done();\n    });\n  }\n  else { done(); }\n});\n\nvar sauceConnectProcess = null;\n\ngulp.task('start-sc', function(done) {\n  var opts = {\n    username: process.env.SAUCE_USERNAME,\n    accessKey: process.env.SAUCE_ACCESS_KEY,\n    verbose: process.env.SAUCE_CONNECT_VERBOSE,\n    directDomains: 'cdnjs.cloudflare.com,html5shiv.googlecode.com',\n    logger: function(mess) {console.log(mess);}\n  };\n  if(process.env.TRAVIS_JOB_NUMBER) {\n    opts.tunnelIdentifier = process.env.TRAVIS_JOB_NUMBER;\n  }\n  var startTunnel = function(done, n) {\n    sauceConnectLauncher(opts, function (err, _sauceConnectProcess) {\n      if (err) {\n        if(n > 0) {\n          console.log('retrying sauce connect in 20 secs.');\n          setTimeout(function() {\n            startTunnel(done, n-1);\n          }, 20000);\n        } else {\n          console.error(err.message);\n          done(err);\n        }\n        return;\n      }\n      sauceConnectProcess = _sauceConnectProcess;\n      console.log(\"Sauce Connect ready\");\n      done();\n    });\n  };\n\n  startTunnel(done, 3);\n});\n\ngulp.task('stop-sc', function(done) {\n  if(sauceConnectProcess) { sauceConnectProcess.close(done); }\n  else { done(); }\n});\n\ngulp.task('pre-midway', function() {\n  var seq = ['start-proxy'];\n  if(args.sauce && !args['nosc']) {\n    seq.unshift('start-sc');\n  }\n  return runSequence(seq);\n});\n\ngulp.task('post-midway', function() {\n  var seq = ['stop-proxy'];\n  if(args.sauce && !args['nosc']) {\n    seq.unshift('stop-sc');\n  }\n  return runSequence(seq);\n});\n\ngulp.task('travis', function() {\n  var seq;\n  switch(args.config) {\n    case 'unit':\n      return runSequence(['test-unit']);\n    case 'multi':\n      args.browsers= [args.config];\n      return runSequence(['test-midway']);\n    case 'chrome':\n    case 'firefox':\n    case 'explorer':\n      args.browsers= [args.config];\n      return runSequence(['test-midway','test-e2e']);\n    case 'iphone':\n    case 'ipad':\n    case 'android_phone':\n      args.browsers= [args.config];\n      return runSequence(['test-midway']);\n    case 'chrome_e2e':\n      args.browsers= ['chrome'];\n      return runSequence(['test-e2e']);\n  }\n  return runSequence.apply(null, seq);\n});\n","/home/travis/build/npmtest/node-npmtest-wd/node_modules/wd/lib/deprecated-chain.js":"var async = require(\"async\");\nvar _ = require(\"./lodash\");\n\nvar deprecatedChain ={};\n\ndeprecatedChain.chain = function(obj){\n  var _this = this;\n  if (!obj) { obj = {}; }\n\n  // Update the onError callback if supplied.  The most recent .chain()\n  // invocation overrides previous onError handlers.\n  if (obj.onError) {\n    this._chainOnErrorCallback = obj.onError;\n  } else if (!this._chainOnErrorCallback) {\n    this._chainOnErrorCallback = function(err) {\n      if (err) { console.error(\"a function in your .chain() failed:\", err); }\n    };\n  }\n\n  // Add queue if not already here\n  if(!_this._queue){\n    _this._queue = async.queue(function (task, callback) {\n      if(task.args.length > 0 && typeof task.args[task.args.length-1] === \"function\"){\n        //wrap the existing callback\n        //if this is queueAddAsync, we instead create a callback that will be\n        //passed through to the function provided\n        var cb_arg = (task.name === 'queueAddAsync' ? 1 : task.args.length - 1);\n        var func = task.args[cb_arg];\n        task.args[cb_arg] = function(err) {\n          // if the chain user has their own callback, we will not invoke\n          // the onError handler, supplying your own callback suggests you\n          // handle the error on your own.\n          if (func)\n            { func.apply(null, arguments); }\n          if (!_this._chainHalted) { callback(err); }\n        };\n      } else {\n        // if the .chain() does not supply a callback, we assume they\n        // expect us to catch errors.\n        task.args.push(function(err) {\n          // if there is an error, call the onError callback,\n          // and do not invoke callback() which would make the\n          // task queue continue processing\n          if (err) { _this._chainOnErrorCallback(err); }\n          else { callback(); }\n        });\n      }\n\n      //call the function\n      _this[task.name].apply(_this, task.args);\n    }, 1);\n\n    // add unshift method if we need to add sth to the queue\n    _this._queue = _.extend(_this._queue, {\n      unshift: function (data, callback) {\n        var _this = this;\n        if(data.constructor !== Array) {\n            data = [data];\n        }\n        data.forEach(function(task) {\n            _this.tasks.unshift({\n                data: task,\n                callback: typeof callback === 'function' ? callback : null\n            });\n            if (_this.saturated && _this.tasks.length === _this.concurrency) {\n                _this.saturated();\n            }\n            async.nextTick(_this.process);\n        });\n      }\n    });\n  }\n\n  var chain = {};\n\n  //builds a placeHolder functions\n  var buildPlaceholder = function(name){\n    return function(){\n      _this._queue.push({name: name, args: Array.prototype.slice.call(arguments, 0)});\n      return chain;\n    };\n  };\n\n  //fill the chain with placeholders\n  _.each(_.functionsIn(_this), function(k) {\n    if(k !== \"chain\"){\n      chain[k] = buildPlaceholder(k);\n    }\n  });\n\n  return chain;\n};\n\n// manually stop processing of queued chained functions\ndeprecatedChain.haltChain = function(){\n  this._chainHalted = true;\n  this._queue = null;\n};\n\ndeprecatedChain.pauseChain = function(timeoutMs, cb){\n  setTimeout(function() {\n    cb();\n  }, timeoutMs);\n  return this.chain;\n};\n\ndeprecatedChain.next = function(){\n  this._queue.unshift({name: arguments[0], args: _.drop(arguments)});\n};\n\ndeprecatedChain.queueAdd = function(func){\n  func();\n  return this.chain;\n};\n\ndeprecatedChain.queueAddAsync = function(func, cb) {\n  func(cb);\n  return this.chain;\n};\n\nmodule.exports = {\n  patch: function(browser) {\n    _(deprecatedChain).methods().each(function(methodName) {\n      browser[methodName] = deprecatedChain[methodName].bind(browser);\n    });\n  }\n};\n"}